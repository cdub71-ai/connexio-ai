import _m0 from "protobufjs/minimal";
import { MetadataStatus, VariableType } from "./common_enums";
import { Comparator, TaskNode, UTActionTrigger, VariableAssignment, VariableDef, VariableMutation } from "./common_wfspec";
import { ExternalEventDefId, WfSpecId, WorkflowEventDefId } from "./object_id";
/** Determines the Access Level for a Variable in a ThreadSpec/WfSpec. */
export declare enum WfRunVariableAccessLevel {
    /** PUBLIC_VAR - A `PUBLIC_VAR` can be accessed (read + mutated) by child `WfRun`'s. */
    PUBLIC_VAR = "PUBLIC_VAR",
    /** PRIVATE_VAR - A `PRIVATE_VAR` cannot be accessed by a child `WfRun`. */
    PRIVATE_VAR = "PRIVATE_VAR",
    /**
     * INHERITED_VAR - An `INHERITED_VAR` is inherited from the parent `WfRun`. Only valid in a `WfSpec` that
     * has a parent. Also can only be declared in the Entrypoint Thread.
     */
    INHERITED_VAR = "INHERITED_VAR",
    UNRECOGNIZED = "UNRECOGNIZED"
}
export declare function wfRunVariableAccessLevelFromJSON(object: any): WfRunVariableAccessLevel;
export declare function wfRunVariableAccessLevelToNumber(object: WfRunVariableAccessLevel): number;
/**
 * A `WfSpec` defines the logic for a workflow in LittleHorse. It is a metadata object
 * and is a blueprint for a `WfRun` execution.
 */
export interface WfSpec {
    /**
     * The ID of the `WfSpec`. Note that this ID is versioned with both a major
     * version and a minor revision. Creating new WfSpec's with the same name
     * and different specifications results in a completely new `WfSpec` object
     * whose `id.name` is the same but with different version.
     */
    id: WfSpecId | undefined;
    /** The timestamp at which the `WfSpec` was created. */
    createdAt: string | undefined;
    /**
     * Variables whose types cannot be changed without causing a Breaking Change between
     * the versions.
     */
    frozenVariables: ThreadVarDef[];
    /**
     * The Status of the `WfSpec`. Currently, only `ACTIVE` exists. This field will be
     * used in the future when de-commissioning a WfSpec gracefully.
     */
    status: MetadataStatus;
    /**
     * The various ThreadSpec's in this `WfSpec`. Each `ThreadSpec` defines a blueprint for
     * a parallel thread of execution (a `ThreadRun`). They are referred to by their names.
     */
    threadSpecs: {
        [key: string]: ThreadSpec;
    };
    /**
     * The name of the `ENTRYPOINT` ThreadSpec. The Entrypoint is the `ThreadSpec` for the
     * Entrypoint ThreadRun, which is the `ThreadRun` that is created upon starting the
     * `WfRun`.
     */
    entrypointThreadName: string;
    /**
     * Optional policy that configures cleaning up old `WfRun`'s after they are completed or
     * failed. Recommended for production settings to avoid running out of disk space; unless
     * you are using a `WfRun` as a data record, in which case the application should
     * clean up `WfRun`'s as appropriate.
     */
    retentionPolicy?: WorkflowRetentionPolicy | undefined;
    /** EXPERIMENTAL: ongoing migration from one version of a `WfSpec` to another. */
    migration?: WfSpecVersionMigration | undefined;
    /**
     * Reference to the parent WfSpec. If this is set, all WfRun's for this WfSpec must be the
     * child of a WfRun belonging to the referenced WfSpec.
     */
    parentWfSpec?: WfSpec_ParentWfSpecReference | undefined;
}
export interface WfSpec_ThreadSpecsEntry {
    key: string;
    value: ThreadSpec | undefined;
}
/**
 * Reference to another WfSpec. If a WfSpec has a ParentWfSpecReference, then all
 * WfRun's for that WfSpec *MUST* be the child of a WfRun of the provided WfSpec; meaning
 * that the RunWf RPC must provide a `parent_wf_run_id` that belongs to the specified
 * WfSpec.
 *
 * Currently, only reference by names is supported.
 */
export interface WfSpec_ParentWfSpecReference {
    /** Name of the Parent WfSpec */
    wfSpecName: string;
    /**
     * FOR NOW: no validation of variables on parent. In the future we will pass
     * wf_spec_major_version, but we should probably examine the rules for
     * evolution in the future.
     */
    wfSpecMajorVersion: number;
}
/**
 * A WorkflowRetentionPolicy configures how long a WfRun is retained in the data store before
 * being deleted after it is completed or failed.
 */
export interface WorkflowRetentionPolicy {
    /**
     * Delete all WfRun's X seconds after they terminate, regardless of
     * status.
     */
    secondsAfterWfTermination?: number | undefined;
}
/**
 * Defines an index to make a JSON_OBJ or JSON_ARR variable searchable over a specific
 * JSON Path.
 */
export interface JsonIndex {
    /**
     * Denotes the path in JSONPath format (according to the Java Jayway library) that
     * has a field we should index.
     */
    fieldPath: string;
    /** Is the type of the field we are indexing. */
    fieldType: VariableType;
}
/** Denotes a variable declaration at the ThreadSpec level. */
export interface ThreadVarDef {
    /** Is the actual VariableDefinition containing name and type. */
    varDef: VariableDef | undefined;
    /** Whether the variable is required as input to the threadRun. */
    required: boolean;
    /** Whether this variable has an index configured. */
    searchable: boolean;
    /**
     * Valid for JSON_OBJ and JSON_ARR variables only. List of JSON fields
     * to index.
     */
    jsonIndexes: JsonIndex[];
    /** The Access Level of this variable. */
    accessLevel: WfRunVariableAccessLevel;
}
/**
 * Defines a blueprint for a ThreadRun, which is a thread of execution inside a
 * WfRun.
 */
export interface ThreadSpec {
    /** The Nodes inside this ThreadSpec. Maps from name to Node. */
    nodes: {
        [key: string]: Node;
    };
    /** Defines Variables that are local to ThreadRun's of this ThreadSpec. */
    variableDefs: ThreadVarDef[];
    /** Defines all interrupts for this ThreadSpec. */
    interruptDefs: InterruptDef[];
    /**
     * Optional retention policy to clean up ThreadRun's of this ThreadSpec after they
     * have been completed. This is important for long-lived WfRun's that could have
     * hundreds of ThreadRun's, because a ThreadRun has a record inside the WfRun itself.
     */
    retentionPolicy?: ThreadRetentionPolicy | undefined;
}
export interface ThreadSpec_NodesEntry {
    key: string;
    value: Node | undefined;
}
/**
 * ThreadRetentionPolicy specifies how long to keep record of a ThreadRun and its associated
 * NodeRun's and TaskRun's and Variables after the ThreadRun has been completed.
 */
export interface ThreadRetentionPolicy {
    /**
     * Delete associated ThreadRun's X seconds after they terminate, regardless
     * of status.
     */
    secondsAfterThreadTermination?: number | undefined;
}
/**
 * Defines an Interrupt for a ThreadSpec. An Interrupt means that when an ExternalEvent
 * of a certain type is registered to the WfRun, then the affected ThreadRun is HALTED
 * and a handler ThreadRun is run as an interrupt handler. The interrupted ThreadRun
 * is resumed once the interrupt handler completes.
 */
export interface InterruptDef {
    /**
     * The ID of the ExternalEventDef which triggers an Interrupt for this ThreadSpec.
     * Note that as of 0.9.0, you cannot use an ExternalEventDefId for both an InterruptDef
     * and an ExternalEventNode in the same WfSpec.
     */
    externalEventDefId: ExternalEventDefId | undefined;
    /** The name of the ThreadSpec that we run as the interrupt handler. */
    handlerSpecName: string;
}
/** Starts a Child ThreadRun with a specific ThreadSpec. */
export interface StartThreadNode {
    /** The name of the ThreadSpec to spawn. */
    threadSpecName: string;
    /** The input variables to pass into the Child ThreadRun. */
    variables: {
        [key: string]: VariableAssignment;
    };
}
export interface StartThreadNode_VariablesEntry {
    key: string;
    value: VariableAssignment | undefined;
}
/**
 * Iterates over a JSON_ARR and starts a Child ThreadRun for each element in the
 * list.
 *
 * Returns a JSON_ARR containing the thread_run_number of each spawned child.
 */
export interface StartMultipleThreadsNode {
    /** The name of the ThreadSpec to spawn. */
    threadSpecName: string;
    /**
     * Variables which are passed into the child ThreadRuns. These assignments are
     * the same for all spawned threads.
     */
    variables: {
        [key: string]: VariableAssignment;
    };
    /**
     * Assignment that resolves to a JSON_ARR. For each element in the list, a child
     * ThreadRun is started. The reserved `INPUT` variable for each Child is set to the
     * corresponding item in the list.
     */
    iterable: VariableAssignment | undefined;
}
export interface StartMultipleThreadsNode_VariablesEntry {
    key: string;
    value: VariableAssignment | undefined;
}
/**
 * Specifies a Failure Handler which can run in case of a certain Failure to allow
 * the ThreadRun to run compensatory logic and gracefully continue rather than
 * failing immediately.
 */
export interface FailureHandlerDef {
    /** The name of the ThreadSpec to run as a */
    handlerSpecName: string;
    /**
     * Specifies that this FailureHandlerDef will be triggered for a Failure with this
     * exact name.
     *
     * If this and `specific_failure` are both unset, then any failure is caught.
     */
    specificFailure?: string | undefined;
    /**
     * Specifies that this FailureHandlerDef will be triggered for any failure matching
     * this type (ERROR or EXCEPTION).
     */
    anyFailureOfType?: FailureHandlerDef_LHFailureType | undefined;
}
/** Specifies a type of Failure */
export declare enum FailureHandlerDef_LHFailureType {
    /** FAILURE_TYPE_ERROR - FAILURE_TYPE_ERROR specifies any technical `ERROR`. */
    FAILURE_TYPE_ERROR = "FAILURE_TYPE_ERROR",
    /** FAILURE_TYPE_EXCEPTION - Specifies a user-defined, business-related `EXCEPTION`. */
    FAILURE_TYPE_EXCEPTION = "FAILURE_TYPE_EXCEPTION",
    UNRECOGNIZED = "UNRECOGNIZED"
}
export declare function failureHandlerDef_LHFailureTypeFromJSON(object: any): FailureHandlerDef_LHFailureType;
export declare function failureHandlerDef_LHFailureTypeToNumber(object: FailureHandlerDef_LHFailureType): number;
/**
 * Specifies that a ThreadRun will wait for certain specified Child ThreadRun's to
 * complete or fail before the WfRun continues. If one of the Child ThreadRun's
 * throws a Failure that is not caught by the `per_thread_failure_handlers`,
 * then the Child ThreadRun's Failure is thrown by the WaitForThreadsRun.
 *
 * No output.
 */
export interface WaitForThreadsNode {
    /**
     * Specifies that the WaitForThreadsRun will wait for the threads specified
     * here.
     */
    threads?: WaitForThreadsNode_ThreadsToWaitFor | undefined;
    /**
     * Specifies that the WaitForThreadsRun will wait for a list of ThreadRun's contained
     * in the JSON_ARR value specified here. Each element in the list must be an INT
     * representing the `number` of a ThreadRun that we're waiting for.
     */
    threadList?: VariableAssignment | undefined;
    /**
     * If any of the child ThreadRun's that we are waiting for throw a Failure, we will
     * evaluate it against these FailureHandlerDef's and run the first matching FailureHandler
     * (if any). The FailureHandler will be a child of the child, which means that it has
     * access to all of the variables in the scope of the failed Child ThreadRun.
     *
     * This is different from Node-level Failure Handlers, which would be _siblings_ of the
     * ThreadRuns that we're waiting for, and would run only when the overall nodeRun has
     * failed.
     */
    perThreadFailureHandlers: FailureHandlerDef[];
}
export interface WaitForThreadsNode_ThreadToWaitFor {
    /**
     * Causes the WaitForThreadsNodeRun to wait for the ThreadRun whose number
     * matches the value specified here. Must resolve to an INT.
     */
    threadRunNumber: VariableAssignment | undefined;
}
export interface WaitForThreadsNode_ThreadsToWaitFor {
    /** Wait for one or more ThreadRun's */
    threads: WaitForThreadsNode_ThreadToWaitFor[];
}
/**
 * An ExternalEventNode causes the WfRun to stop and wait for an ExternalEvent
 * to arrive before continuing onwards.
 *
 * The output is just the content of the ExternalEvent.
 */
export interface ExternalEventNode {
    /** The ID of the ExternalEventDef that we are waiting for. */
    externalEventDefId: ExternalEventDefId | undefined;
    /**
     * Determines the maximum amount of time that the NodeRun will wait for the
     * ExternalEvent to arrive.
     */
    timeoutSeconds: VariableAssignment | undefined;
}
/**
 * Defines the beginning of the ThreadRun execution.
 *
 * Output is NULL
 */
export interface EntrypointNode {
}
/** Defines the end of the ThreadRun execution. */
export interface ExitNode {
    /**
     * If set, this ExitNode throws the specified Failure upon arrival. Note that Failures
     * are propagated up to the parent ThreadRun (or cause the entire WfRun to fail if sent
     * by the entrypoint ThreadRun).
     *
     * If this is not set, then a ThreadRun arriving at this Exit Node will be COMPLETED.
     */
    failureDef?: FailureDef | undefined;
}
/** Defines a Failure that can be thrown. */
export interface FailureDef {
    /**
     * The code for the failure. If in UPPER_CASE, it must be one of the LHErrorType
     * enums, and represents an ERROR. If it is in kebab-case, then it is a user-defined
     * EXCEPTION.
     */
    failureName: string;
    /** Human-readable message denoting why the Failure occurred. */
    message: string;
    /** If specified, the thrown Failure will have this content. */
    content?: VariableAssignment | undefined;
}
/** A Node is a step in a ThreadRun. */
export interface Node {
    /** Defines the flow of execution and determines where the ThreadRun goes next. */
    outgoingEdges: Edge[];
    /**
     * Specifies handlers for failures (EXCEPTION or ERROR or both) which might be thrown
     * by the NodeRun. If a Failure is thrown by the Node execution, then the first
     * matching Failure Handler (if present) is run. If there is a matching Failure Handler
     * and it runs to completion, then the ThreadRun advances from the Node; else, it
     * fails.
     */
    failureHandlers: FailureHandlerDef[];
    /** Creates an EntrypointRun. Every ThreadRun has one Entrypoint node. */
    entrypoint?: EntrypointNode | undefined;
    /** Creates an `ExitRun``. Every ThreadSpec has at least one Exit Node. */
    exit?: ExitNode | undefined;
    /** Creates a TaskNodeRUn */
    task?: TaskNode | undefined;
    /** Creates an ExternalEventRun */
    externalEvent?: ExternalEventNode | undefined;
    /** Creates a StartThreadNodeRun */
    startThread?: StartThreadNode | undefined;
    /** Creates a WaitForThreadsNodeRun */
    waitForThreads?: WaitForThreadsNode | undefined;
    /** Creates a NopNodeRun */
    nop?: NopNode | undefined;
    /** Creates a SleepNodeRun */
    sleep?: SleepNode | undefined;
    /** Creates a UserTaskNodeRun */
    userTask?: UserTaskNode | undefined;
    /** Creates a StartMultipleThreadsNodeRun */
    startMultipleThreads?: StartMultipleThreadsNode | undefined;
    /** Creates a ThrowEventNodeRun */
    throwEvent?: ThrowEventNode | undefined;
}
/** A SubNode that throws a WorkflowEvent of a specific type. There is no output. */
export interface ThrowEventNode {
    /** The WorkflowEventDefId of the WorkflowEvent that is thrown */
    eventDefId: WorkflowEventDefId | undefined;
    /** A VariableAssignment defining the content of the WorkflowEvent that is thrown */
    content: VariableAssignment | undefined;
}
/**
 * The UserTaskNode creates a UserTaskRun, which is used to get input from a human
 * user into the workflow.
 *
 * The output is a JSON_OBJ variable with one key/value pair for each UserTaskField.
 */
export interface UserTaskNode {
    /** Denotes the name of the `UserTaskDef` that should create the `UserTaskRun`. */
    userTaskDefName: string;
    /** Denotes the user_group to which the UserTaskRun is assigned upon creation. */
    userGroup?: VariableAssignment | undefined;
    /** Denotes the user_id to which the UserTaskRun is assigned upon creation. */
    userId?: VariableAssignment | undefined;
    /**
     * Specifies a list of actions that happen on various time-based triggers. Actions
     * include reassigning the UserTaskRun, cancelling the UserTaskRun, or executing
     * a "reminder" TaskRun.
     */
    actions: UTActionTrigger[];
    /**
     * If set, then the UserTaskRun will always have this specific version of the
     * UserTaskDef. Otherwise, the UserTaskRun will have the latest version.
     */
    userTaskDefVersion?: number | undefined;
    /** Specifies the value to be displayed on the `notes` field of the UserTaskRun. */
    notes?: VariableAssignment | undefined;
    /**
     * Specifies the name of the exception thrown when the User Task is canceled. If
     * not set, then the cancellation or timeout of a User Task Run throws an ERROR
     * rather than an EXCEPTION.
     */
    onCancellationExceptionName?: VariableAssignment | undefined;
}
/** This is a boolean expression used to evaluate whether an Edge is valid. */
export interface EdgeCondition {
    /** The Operator used to evaluate the left versus the right. */
    comparator: Comparator;
    /** The left side of the boolean expression. */
    left: VariableAssignment | undefined;
    /** The right side of the Boolean Expression. */
    right: VariableAssignment | undefined;
}
/** The Edge is the line in the workflow that connects one Node to another. */
export interface Edge {
    /** The name of the Node that the Edge points to. */
    sinkNodeName: string;
    /**
     * The Condition on which this Edge will be traversed. When choosing an Edge
     * to travel after the completion of a NodeRun, the Edges are evaluated in
     * order. The first one to either have no condition or have a condition which
     * evaluates to `true` is taken.
     */
    condition?: EdgeCondition | undefined;
    /** Ordered list of Variable Mutations to execute when traversing this Edge. */
    variableMutations: VariableMutation[];
}
/** NOP node has no operations and is used for conditional branching. */
export interface NopNode {
}
/**
 * Sleep Node causes the WfRun to wait a specified time and then resume.
 *
 * There is no output.
 */
export interface SleepNode {
    /** Sleeps the specified number of seconds. */
    rawSeconds?: VariableAssignment | undefined;
    /** Sleeps until the `long` timestamp (epoch millis) specified here. */
    timestamp?: VariableAssignment | undefined;
    /** Sleeps until the ISO-formatted date specified here. */
    isoDate?: VariableAssignment | undefined;
}
/**
 * EXPERIMENTAL: Specification for how to migrate an in-flight WfRun from one WfSpec
 * to another WfSpec version.
 */
export interface WfSpecVersionMigration {
    /** The major version of the WfSpec that we are migrating to. */
    newMajorVersion: number;
    /** The revision of the WfSpec that we are migrating to. */
    newRevision: number;
    /**
     * Map from ThreadSpec name to a specifier determining how to migrate ThreadRun's
     * to the new version of the WfSpec.
     */
    threadSpecMigrations: {
        [key: string]: ThreadSpecMigration;
    };
}
export interface WfSpecVersionMigration_ThreadSpecMigrationsEntry {
    key: string;
    value: ThreadSpecMigration | undefined;
}
/**
 * EXPERIMENTAL: Specification for how to migrate a ThreadRun of a specific ThreadSpec
 * from one WfSpec to another WfSpec version.
 */
export interface ThreadSpecMigration {
    /**
     * The name of the ThreadSpec in the new WfSpec that this ThreadSpec should
     * migrate to.
     */
    newThreadSpecName: string;
    /**
     * Map from name of the nodes on the current ThreadSpec to the migration
     * to perform on it to move it to a new WfSpec.
     */
    nodeMigrations: {
        [key: string]: NodeMigration;
    };
}
export interface ThreadSpecMigration_NodeMigrationsEntry {
    key: string;
    value: NodeMigration | undefined;
}
/**
 * EXPERIMENTAL: Specification for migrating a WfRun from a Node in one WfSpec
 * to a Node in another WfSpec version.
 */
export interface NodeMigration {
    /** The name of the Node on the new WfSpec to move to. */
    newNodeName: string;
}
export declare const WfSpec: {
    encode(message: WfSpec, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): WfSpec;
    create(base?: DeepPartial<WfSpec>): WfSpec;
    fromPartial(object: DeepPartial<WfSpec>): WfSpec;
};
export declare const WfSpec_ThreadSpecsEntry: {
    encode(message: WfSpec_ThreadSpecsEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): WfSpec_ThreadSpecsEntry;
    create(base?: DeepPartial<WfSpec_ThreadSpecsEntry>): WfSpec_ThreadSpecsEntry;
    fromPartial(object: DeepPartial<WfSpec_ThreadSpecsEntry>): WfSpec_ThreadSpecsEntry;
};
export declare const WfSpec_ParentWfSpecReference: {
    encode(message: WfSpec_ParentWfSpecReference, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): WfSpec_ParentWfSpecReference;
    create(base?: DeepPartial<WfSpec_ParentWfSpecReference>): WfSpec_ParentWfSpecReference;
    fromPartial(object: DeepPartial<WfSpec_ParentWfSpecReference>): WfSpec_ParentWfSpecReference;
};
export declare const WorkflowRetentionPolicy: {
    encode(message: WorkflowRetentionPolicy, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): WorkflowRetentionPolicy;
    create(base?: DeepPartial<WorkflowRetentionPolicy>): WorkflowRetentionPolicy;
    fromPartial(object: DeepPartial<WorkflowRetentionPolicy>): WorkflowRetentionPolicy;
};
export declare const JsonIndex: {
    encode(message: JsonIndex, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): JsonIndex;
    create(base?: DeepPartial<JsonIndex>): JsonIndex;
    fromPartial(object: DeepPartial<JsonIndex>): JsonIndex;
};
export declare const ThreadVarDef: {
    encode(message: ThreadVarDef, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ThreadVarDef;
    create(base?: DeepPartial<ThreadVarDef>): ThreadVarDef;
    fromPartial(object: DeepPartial<ThreadVarDef>): ThreadVarDef;
};
export declare const ThreadSpec: {
    encode(message: ThreadSpec, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ThreadSpec;
    create(base?: DeepPartial<ThreadSpec>): ThreadSpec;
    fromPartial(object: DeepPartial<ThreadSpec>): ThreadSpec;
};
export declare const ThreadSpec_NodesEntry: {
    encode(message: ThreadSpec_NodesEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ThreadSpec_NodesEntry;
    create(base?: DeepPartial<ThreadSpec_NodesEntry>): ThreadSpec_NodesEntry;
    fromPartial(object: DeepPartial<ThreadSpec_NodesEntry>): ThreadSpec_NodesEntry;
};
export declare const ThreadRetentionPolicy: {
    encode(message: ThreadRetentionPolicy, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ThreadRetentionPolicy;
    create(base?: DeepPartial<ThreadRetentionPolicy>): ThreadRetentionPolicy;
    fromPartial(object: DeepPartial<ThreadRetentionPolicy>): ThreadRetentionPolicy;
};
export declare const InterruptDef: {
    encode(message: InterruptDef, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): InterruptDef;
    create(base?: DeepPartial<InterruptDef>): InterruptDef;
    fromPartial(object: DeepPartial<InterruptDef>): InterruptDef;
};
export declare const StartThreadNode: {
    encode(message: StartThreadNode, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): StartThreadNode;
    create(base?: DeepPartial<StartThreadNode>): StartThreadNode;
    fromPartial(object: DeepPartial<StartThreadNode>): StartThreadNode;
};
export declare const StartThreadNode_VariablesEntry: {
    encode(message: StartThreadNode_VariablesEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): StartThreadNode_VariablesEntry;
    create(base?: DeepPartial<StartThreadNode_VariablesEntry>): StartThreadNode_VariablesEntry;
    fromPartial(object: DeepPartial<StartThreadNode_VariablesEntry>): StartThreadNode_VariablesEntry;
};
export declare const StartMultipleThreadsNode: {
    encode(message: StartMultipleThreadsNode, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): StartMultipleThreadsNode;
    create(base?: DeepPartial<StartMultipleThreadsNode>): StartMultipleThreadsNode;
    fromPartial(object: DeepPartial<StartMultipleThreadsNode>): StartMultipleThreadsNode;
};
export declare const StartMultipleThreadsNode_VariablesEntry: {
    encode(message: StartMultipleThreadsNode_VariablesEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): StartMultipleThreadsNode_VariablesEntry;
    create(base?: DeepPartial<StartMultipleThreadsNode_VariablesEntry>): StartMultipleThreadsNode_VariablesEntry;
    fromPartial(object: DeepPartial<StartMultipleThreadsNode_VariablesEntry>): StartMultipleThreadsNode_VariablesEntry;
};
export declare const FailureHandlerDef: {
    encode(message: FailureHandlerDef, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FailureHandlerDef;
    create(base?: DeepPartial<FailureHandlerDef>): FailureHandlerDef;
    fromPartial(object: DeepPartial<FailureHandlerDef>): FailureHandlerDef;
};
export declare const WaitForThreadsNode: {
    encode(message: WaitForThreadsNode, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): WaitForThreadsNode;
    create(base?: DeepPartial<WaitForThreadsNode>): WaitForThreadsNode;
    fromPartial(object: DeepPartial<WaitForThreadsNode>): WaitForThreadsNode;
};
export declare const WaitForThreadsNode_ThreadToWaitFor: {
    encode(message: WaitForThreadsNode_ThreadToWaitFor, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): WaitForThreadsNode_ThreadToWaitFor;
    create(base?: DeepPartial<WaitForThreadsNode_ThreadToWaitFor>): WaitForThreadsNode_ThreadToWaitFor;
    fromPartial(object: DeepPartial<WaitForThreadsNode_ThreadToWaitFor>): WaitForThreadsNode_ThreadToWaitFor;
};
export declare const WaitForThreadsNode_ThreadsToWaitFor: {
    encode(message: WaitForThreadsNode_ThreadsToWaitFor, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): WaitForThreadsNode_ThreadsToWaitFor;
    create(base?: DeepPartial<WaitForThreadsNode_ThreadsToWaitFor>): WaitForThreadsNode_ThreadsToWaitFor;
    fromPartial(object: DeepPartial<WaitForThreadsNode_ThreadsToWaitFor>): WaitForThreadsNode_ThreadsToWaitFor;
};
export declare const ExternalEventNode: {
    encode(message: ExternalEventNode, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ExternalEventNode;
    create(base?: DeepPartial<ExternalEventNode>): ExternalEventNode;
    fromPartial(object: DeepPartial<ExternalEventNode>): ExternalEventNode;
};
export declare const EntrypointNode: {
    encode(_: EntrypointNode, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EntrypointNode;
    create(base?: DeepPartial<EntrypointNode>): EntrypointNode;
    fromPartial(_: DeepPartial<EntrypointNode>): EntrypointNode;
};
export declare const ExitNode: {
    encode(message: ExitNode, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ExitNode;
    create(base?: DeepPartial<ExitNode>): ExitNode;
    fromPartial(object: DeepPartial<ExitNode>): ExitNode;
};
export declare const FailureDef: {
    encode(message: FailureDef, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): FailureDef;
    create(base?: DeepPartial<FailureDef>): FailureDef;
    fromPartial(object: DeepPartial<FailureDef>): FailureDef;
};
export declare const Node: {
    encode(message: Node, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Node;
    create(base?: DeepPartial<Node>): Node;
    fromPartial(object: DeepPartial<Node>): Node;
};
export declare const ThrowEventNode: {
    encode(message: ThrowEventNode, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ThrowEventNode;
    create(base?: DeepPartial<ThrowEventNode>): ThrowEventNode;
    fromPartial(object: DeepPartial<ThrowEventNode>): ThrowEventNode;
};
export declare const UserTaskNode: {
    encode(message: UserTaskNode, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UserTaskNode;
    create(base?: DeepPartial<UserTaskNode>): UserTaskNode;
    fromPartial(object: DeepPartial<UserTaskNode>): UserTaskNode;
};
export declare const EdgeCondition: {
    encode(message: EdgeCondition, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EdgeCondition;
    create(base?: DeepPartial<EdgeCondition>): EdgeCondition;
    fromPartial(object: DeepPartial<EdgeCondition>): EdgeCondition;
};
export declare const Edge: {
    encode(message: Edge, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Edge;
    create(base?: DeepPartial<Edge>): Edge;
    fromPartial(object: DeepPartial<Edge>): Edge;
};
export declare const NopNode: {
    encode(_: NopNode, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): NopNode;
    create(base?: DeepPartial<NopNode>): NopNode;
    fromPartial(_: DeepPartial<NopNode>): NopNode;
};
export declare const SleepNode: {
    encode(message: SleepNode, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SleepNode;
    create(base?: DeepPartial<SleepNode>): SleepNode;
    fromPartial(object: DeepPartial<SleepNode>): SleepNode;
};
export declare const WfSpecVersionMigration: {
    encode(message: WfSpecVersionMigration, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): WfSpecVersionMigration;
    create(base?: DeepPartial<WfSpecVersionMigration>): WfSpecVersionMigration;
    fromPartial(object: DeepPartial<WfSpecVersionMigration>): WfSpecVersionMigration;
};
export declare const WfSpecVersionMigration_ThreadSpecMigrationsEntry: {
    encode(message: WfSpecVersionMigration_ThreadSpecMigrationsEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): WfSpecVersionMigration_ThreadSpecMigrationsEntry;
    create(base?: DeepPartial<WfSpecVersionMigration_ThreadSpecMigrationsEntry>): WfSpecVersionMigration_ThreadSpecMigrationsEntry;
    fromPartial(object: DeepPartial<WfSpecVersionMigration_ThreadSpecMigrationsEntry>): WfSpecVersionMigration_ThreadSpecMigrationsEntry;
};
export declare const ThreadSpecMigration: {
    encode(message: ThreadSpecMigration, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ThreadSpecMigration;
    create(base?: DeepPartial<ThreadSpecMigration>): ThreadSpecMigration;
    fromPartial(object: DeepPartial<ThreadSpecMigration>): ThreadSpecMigration;
};
export declare const ThreadSpecMigration_NodeMigrationsEntry: {
    encode(message: ThreadSpecMigration_NodeMigrationsEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ThreadSpecMigration_NodeMigrationsEntry;
    create(base?: DeepPartial<ThreadSpecMigration_NodeMigrationsEntry>): ThreadSpecMigration_NodeMigrationsEntry;
    fromPartial(object: DeepPartial<ThreadSpecMigration_NodeMigrationsEntry>): ThreadSpecMigration_NodeMigrationsEntry;
};
export declare const NodeMigration: {
    encode(message: NodeMigration, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): NodeMigration;
    create(base?: DeepPartial<NodeMigration>): NodeMigration;
    fromPartial(object: DeepPartial<NodeMigration>): NodeMigration;
};
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
type DeepPartial<T> = T extends Builtin ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
export {};
//# sourceMappingURL=wf_spec.d.ts.map