import _m0 from "protobufjs/minimal";
import { VariableType } from "./common_enums";
import { TaskDefId } from "./object_id";
import { VariableValue } from "./variable";
/** Enumerates the available operations to mutate a variable in a WfRun. */
export declare enum VariableMutationType {
    /** ASSIGN - Set the variable specified by the LHS to the value of the RHS. */
    ASSIGN = "ASSIGN",
    /** ADD - Add the RHS to the LHS. */
    ADD = "ADD",
    /** EXTEND - Append the RHS to the LHS (valid if the LHS is a STR or JSON_ARR) */
    EXTEND = "EXTEND",
    /** SUBTRACT - Subtract the RHS from the LHS (both must be INT or DOUBLE) */
    SUBTRACT = "SUBTRACT",
    /** MULTIPLY - Multiply the LHS by the RHS (both must be INT or DOUBLE) */
    MULTIPLY = "MULTIPLY",
    /** DIVIDE - Divide the LHS by the RHS (both must be INT or DOUBLE) */
    DIVIDE = "DIVIDE",
    /** REMOVE_IF_PRESENT - Remove any occurrences of RHS from LHS (LHS must be JSON_ARR) */
    REMOVE_IF_PRESENT = "REMOVE_IF_PRESENT",
    /** REMOVE_INDEX - Remove item at index RHS from LHS (LHS must be JSON_ARR) */
    REMOVE_INDEX = "REMOVE_INDEX",
    /** REMOVE_KEY - Remove the key specified by RHS from the LHS (LHS must be JSON_OBJ) */
    REMOVE_KEY = "REMOVE_KEY",
    UNRECOGNIZED = "UNRECOGNIZED"
}
export declare function variableMutationTypeFromJSON(object: any): VariableMutationType;
export declare function variableMutationTypeToNumber(object: VariableMutationType): number;
/** Operator for comparing two values to create a boolean expression. */
export declare enum Comparator {
    /** LESS_THAN - Equivalent to `<`. Only valid for primitive types (no JSON_OBJ or JSON_ARR). */
    LESS_THAN = "LESS_THAN",
    /** GREATER_THAN - Equivalent to `>`. Only valid for primitive types (no JSON_OBJ or JSON_ARR). */
    GREATER_THAN = "GREATER_THAN",
    /** LESS_THAN_EQ - Equivalent to `<=`. Only valid for primitive types (no JSON_OBJ or JSON_ARR). */
    LESS_THAN_EQ = "LESS_THAN_EQ",
    /** GREATER_THAN_EQ - Equivalent to `>=`. Only valid for primitive types (no JSON_OBJ or JSON_ARR). */
    GREATER_THAN_EQ = "GREATER_THAN_EQ",
    /**
     * EQUALS - This is valid for any variable type, and is similar to .equals() in Java.
     *
     * One note: if the RHS is a different type from the LHS, then LittleHorse will
     * try to cast the RHS to the same type as the LHS. If the cast fails, then the
     * ThreadRun fails with a VAR_SUB_ERROR.
     */
    EQUALS = "EQUALS",
    /** NOT_EQUALS - This is the inverse of `EQUALS` */
    NOT_EQUALS = "NOT_EQUALS",
    /**
     * IN - Only valid if the RHS is a JSON_OBJ or JSON_ARR. Valid for any type on the LHS.
     *
     * For the JSON_OBJ type, this returns true if the LHS is equal to a *KEY* in the
     * RHS. For the JSON_ARR type, it returns true if one of the elements of the RHS
     * is equal to the LHS.
     */
    IN = "IN",
    /** NOT_IN - The inverse of IN. */
    NOT_IN = "NOT_IN",
    UNRECOGNIZED = "UNRECOGNIZED"
}
export declare function comparatorFromJSON(object: any): Comparator;
export declare function comparatorToNumber(object: Comparator): number;
/**
 * A VariableAssignment is used within a WfSpec to determine how a value should be
 * assigned in the context of a specific WfRun. For example, in a TASK node, you
 * use a VariableAssignment for each input parameter to determine how the value
 * is set.
 *
 * Note that the VariableAssignment is normally handled by the SDK; you shouldn't
 * have to worry about this in daily LittleHorse usage.
 */
export interface VariableAssignment {
    /**
     * If you provide a `variable_name` and the specified variable is JSON_OBJ or
     * JSON_ARR type, then you may also provide a json_path which makes the VariableAssignment
     * resolve to the specified field.
     */
    jsonPath?: string | undefined;
    /** Assign the value from a variable. */
    variableName?: string | undefined;
    /** Assign a literal value */
    literalValue?: VariableValue | undefined;
    /** Assign a format string */
    formatString?: VariableAssignment_FormatString | undefined;
}
/** A FormatString formats a template String with values from the WfRun. */
export interface VariableAssignment_FormatString {
    /**
     * A VariableAssignment which must resolve to a String that has format args.
     * A valid string is "This is a format string with three args: {0}, {1}, {2}"
     */
    format: VariableAssignment | undefined;
    /** VariableAssignments which fill out the args. */
    args: VariableAssignment[];
}
/**
 * A VariableMutation defines a modification made to one of a ThreadRun's variables.
 * The LHS determines the variable that is modified; the operation determines how
 * it is modified, and the RHS is the input to the operation.
 *
 * Day-to-day users of LittleHorse generally don't interact with this structure unless
 * they are writing their own WfSpec SDK.
 */
export interface VariableMutation {
    /** The name of the variable to mutate */
    lhsName: string;
    /**
     * For JSON_ARR and JSON_OBJ variables, this allows you to optionally mutate
     * a specific sub-field of the variable.
     */
    lhsJsonPath?: string | undefined;
    /** Defines the operation that we are executing. */
    operation: VariableMutationType;
    /**
     * Set the source_variable as the RHS to use another variable from the workflow to
     * as the RHS/
     */
    sourceVariable?: VariableAssignment | undefined;
    /** Use a literal value as the RHS. */
    literalValue?: VariableValue | undefined;
    /** Use the output of the current node as the RHS. */
    nodeOutput?: VariableMutation_NodeOutputSource | undefined;
}
/** Specifies to use the output of a NodeRun as the RHS. */
export interface VariableMutation_NodeOutputSource {
    /** Use this specific field from a JSON output */
    jsonpath?: string | undefined;
}
/** Declares a Variable. */
export interface VariableDef {
    /** The Type of the variable. */
    type: VariableType;
    /** The name of the variable. */
    name: string;
    /**
     * Optional default value if the variable isn't set; for example, in a ThreadRun
     * if you start a ThreadRun or WfRun without passing a variable in, then this is
     * used.
     */
    defaultValue?: VariableValue | undefined;
}
/**
 * A UTActionTrigger triggers an action upon certain lifecycle hooks
 * in a User Task. Actions include:
 * - re-assign the User Task Run
 * - cancel the User Task Run
 * - execute a Reminder Task
 *
 * Hooks include:
 * - Upon creation of the UserTaskRun
 * - Upon rescheduling the UserTaskRun
 */
export interface UTActionTrigger {
    task?: UTActionTrigger_UTATask | undefined;
    cancel?: UTActionTrigger_UTACancel | undefined;
    /** later on, might enable scheduling entire ThreadRuns */
    reassign?: UTActionTrigger_UTAReassign | undefined;
    /**
     * The Action is triggered some time after the Hook matures. The delay is controlled
     * by this field.
     */
    delaySeconds: VariableAssignment | undefined;
    /** The hook on which this UserTaskAction is scheduled. */
    hook: UTActionTrigger_UTHook;
}
/** Enumerates the different lifecycle hooks that can cause the timer to start running. */
export declare enum UTActionTrigger_UTHook {
    /**
     * ON_ARRIVAL - The hook should be scheduled `delay_seconds` after the UserTaskRun is created. This
     * hook only causes the action to be scheduled once.
     */
    ON_ARRIVAL = "ON_ARRIVAL",
    /**
     * ON_TASK_ASSIGNED - The hook should be scheduled `delay_seconds` after the ownership of the UserTaskRun
     * changes. This hook causes the Action to be scheduled one or more times. The first
     * time is scheduled when the UserTaskRun is created, since we treat the change from
     * "UserTaskRun is nonexistent" to "UserTaskRun is owned by a userId or userGroup" as
     * a change in ownership.
     */
    ON_TASK_ASSIGNED = "ON_TASK_ASSIGNED",
    UNRECOGNIZED = "UNRECOGNIZED"
}
export declare function uTActionTrigger_UTHookFromJSON(object: any): UTActionTrigger_UTHook;
export declare function uTActionTrigger_UTHookToNumber(object: UTActionTrigger_UTHook): number;
/** A UserTaskAction that causes a UserTaskRun to be CANCELLED when it fires. */
export interface UTActionTrigger_UTACancel {
}
/** A UserTaskAction that causes a TaskRun to be scheduled when it fires. */
export interface UTActionTrigger_UTATask {
    /** The specification of the Task to schedule. */
    task: TaskNode | undefined;
    /** EXPERIMENTAL: Any variables in the ThreadRun which we should mutate. */
    mutations: VariableMutation[];
}
/** A UserTaskAction that causes a UserTaskRun to be reassigned when it fires. */
export interface UTActionTrigger_UTAReassign {
    /**
     * A variable assignment that resolves to a STR representing the new user_id. If
     * not set, the user_id of the UserTaskRun will be un-set.
     */
    userId?: VariableAssignment | undefined;
    /**
     * A variable assignment that resolves to a STR representing the new user_group. If
     * not set, the user_group of the UserTaskRun will be un-set.
     */
    userGroup?: VariableAssignment | undefined;
}
/**
 * Defines an Exponential backoff policy for TaskRun retries. The delay for a retry
 * attempt `N` is defined as:
 *
 * min(base_interval_ms * (multiplier ^(N-1)), max_delay_ms)
 *
 * Note that timers in LittleHorse have a resolution of about 500-1000 milliseconds,
 * so timing is not exact.
 */
export interface ExponentialBackoffRetryPolicy {
    /**
     * Base delay in ms for the first retry. Note that in LittleHorse, timers have a
     * resolution of 500-1000 milliseconds. Must be greater than zero.
     */
    baseIntervalMs: number;
    /** Maximum delay in milliseconds between retries. */
    maxDelayMs: number;
    /**
     * The multiplier to use in calculating the retry backoff policy. We recommend
     * starting with 2.0. Must be at least 1.0.
     */
    multiplier: number;
}
/** Defines a TaskRun execution. Used in a Node and also in the UserTask Trigger Actions. */
export interface TaskNode {
    taskDefId?: TaskDefId | undefined;
    dynamicTask?: VariableAssignment | undefined;
    /**
     * How long until LittleHorse determines that the Task Worker had a technical ERROR if
     * the worker does not yet reply to the Server. This is determined on a per-Attempt
     * basis.
     */
    timeoutSeconds: number;
    /**
     * Configures the amount of retries allowed on this TaskNode.
     *
     * Retryable errors include:
     * - TASK_TIMEOUT: the TaskRun was started but the scheduler didn't hear back from the
     *   Task Worker in time.
     * - TASK_FAILED: the Task Worker reported an unexpected *technical* ERROR when executing
     *   the Task Function.
     *
     * Other result codes are not retryable (including TASK_OUTPUT_SERIALIZING_ERROR,
     * TASK_INPUT_VAR_SUB_ERROR, and TASK_EXCEPTION).
     */
    retries: number;
    /** If this field is set, then retries will use Exponential Backoff. */
    exponentialBackoff?: ExponentialBackoffRetryPolicy | undefined;
    /** Input variables into the TaskDef. */
    variables: VariableAssignment[];
}
export declare const VariableAssignment: {
    encode(message: VariableAssignment, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): VariableAssignment;
    create(base?: DeepPartial<VariableAssignment>): VariableAssignment;
    fromPartial(object: DeepPartial<VariableAssignment>): VariableAssignment;
};
export declare const VariableAssignment_FormatString: {
    encode(message: VariableAssignment_FormatString, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): VariableAssignment_FormatString;
    create(base?: DeepPartial<VariableAssignment_FormatString>): VariableAssignment_FormatString;
    fromPartial(object: DeepPartial<VariableAssignment_FormatString>): VariableAssignment_FormatString;
};
export declare const VariableMutation: {
    encode(message: VariableMutation, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): VariableMutation;
    create(base?: DeepPartial<VariableMutation>): VariableMutation;
    fromPartial(object: DeepPartial<VariableMutation>): VariableMutation;
};
export declare const VariableMutation_NodeOutputSource: {
    encode(message: VariableMutation_NodeOutputSource, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): VariableMutation_NodeOutputSource;
    create(base?: DeepPartial<VariableMutation_NodeOutputSource>): VariableMutation_NodeOutputSource;
    fromPartial(object: DeepPartial<VariableMutation_NodeOutputSource>): VariableMutation_NodeOutputSource;
};
export declare const VariableDef: {
    encode(message: VariableDef, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): VariableDef;
    create(base?: DeepPartial<VariableDef>): VariableDef;
    fromPartial(object: DeepPartial<VariableDef>): VariableDef;
};
export declare const UTActionTrigger: {
    encode(message: UTActionTrigger, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UTActionTrigger;
    create(base?: DeepPartial<UTActionTrigger>): UTActionTrigger;
    fromPartial(object: DeepPartial<UTActionTrigger>): UTActionTrigger;
};
export declare const UTActionTrigger_UTACancel: {
    encode(_: UTActionTrigger_UTACancel, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UTActionTrigger_UTACancel;
    create(base?: DeepPartial<UTActionTrigger_UTACancel>): UTActionTrigger_UTACancel;
    fromPartial(_: DeepPartial<UTActionTrigger_UTACancel>): UTActionTrigger_UTACancel;
};
export declare const UTActionTrigger_UTATask: {
    encode(message: UTActionTrigger_UTATask, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UTActionTrigger_UTATask;
    create(base?: DeepPartial<UTActionTrigger_UTATask>): UTActionTrigger_UTATask;
    fromPartial(object: DeepPartial<UTActionTrigger_UTATask>): UTActionTrigger_UTATask;
};
export declare const UTActionTrigger_UTAReassign: {
    encode(message: UTActionTrigger_UTAReassign, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UTActionTrigger_UTAReassign;
    create(base?: DeepPartial<UTActionTrigger_UTAReassign>): UTActionTrigger_UTAReassign;
    fromPartial(object: DeepPartial<UTActionTrigger_UTAReassign>): UTActionTrigger_UTAReassign;
};
export declare const ExponentialBackoffRetryPolicy: {
    encode(message: ExponentialBackoffRetryPolicy, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ExponentialBackoffRetryPolicy;
    create(base?: DeepPartial<ExponentialBackoffRetryPolicy>): ExponentialBackoffRetryPolicy;
    fromPartial(object: DeepPartial<ExponentialBackoffRetryPolicy>): ExponentialBackoffRetryPolicy;
};
export declare const TaskNode: {
    encode(message: TaskNode, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): TaskNode;
    create(base?: DeepPartial<TaskNode>): TaskNode;
    fromPartial(object: DeepPartial<TaskNode>): TaskNode;
};
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
type DeepPartial<T> = T extends Builtin ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
export {};
//# sourceMappingURL=common_wfspec.d.ts.map