import _m0 from "protobufjs/minimal";
import { PrincipalId, TenantId } from "./object_id";
/** Defines a resource type for ACL's. */
export declare enum ACLResource {
    /** ACL_WORKFLOW - Refers to `WfSpec` and `WfRun` */
    ACL_WORKFLOW = "ACL_WORKFLOW",
    /** ACL_TASK - Refers to `TaskDef` and `TaskRun` */
    ACL_TASK = "ACL_TASK",
    /** ACL_EXTERNAL_EVENT - Refers to `ExternalEventDef` and `ExternalEvent` */
    ACL_EXTERNAL_EVENT = "ACL_EXTERNAL_EVENT",
    /** ACL_USER_TASK - Refers to `UserTaskDef` and `UserTaskRun` */
    ACL_USER_TASK = "ACL_USER_TASK",
    /**
     * ACL_PRINCIPAL - Refers to the `Principal` resource. Currently, the `ACL_PRINCIPAL` permission is only
     * valid in the `global_acls` field of the `Principal`. A `Principal` who only has access
     * to a specific Tenant cannot create othe Principals because a Principal is scoped
     * to the Cluster, and not to a Tenant.
     */
    ACL_PRINCIPAL = "ACL_PRINCIPAL",
    /**
     * ACL_TENANT - Refers to the `Tenant` resource. The `ACL_TENANT` permission is only valid in the
     * `global_acls` field of the `Principal`. This is because the `Tenant` resource is
     * cluste-rscoped.
     */
    ACL_TENANT = "ACL_TENANT",
    /**
     * ACL_ALL_RESOURCES - Refers to all resources. In the `global_acls` field, this includes `Principal` and `Tenant`
     * resources. In the `per_tenant_acls` field, this does not include `Principal` and `Tenant` since
     * those are cluster-scoped resources.
     */
    ACL_ALL_RESOURCES = "ACL_ALL_RESOURCES",
    /** ACL_TASK_WORKER_GROUP - Refers to the `TaskWorkerGroup` associated with a TaskDef */
    ACL_TASK_WORKER_GROUP = "ACL_TASK_WORKER_GROUP",
    UNRECOGNIZED = "UNRECOGNIZED"
}
export declare function aCLResourceFromJSON(object: any): ACLResource;
export declare function aCLResourceToNumber(object: ACLResource): number;
/** Describes an Action that can be taken over a specific set of resources. */
export declare enum ACLAction {
    /**
     * READ - Allows all RPC's that start with `Get`, `List`, and `Search` in relation to the
     * metadata (eg. `TaskDef` for `ACL_TASK`) or run data (eg. `TaskRun` for `ACL_TASK`)
     */
    READ = "READ",
    /**
     * RUN - Allows RPC's that are needed for mutating the _runs_ of the resource. For
     * example, `RUN` over `ACL_TASK` allows the `ReportTask` and `PollTask` RPC's,
     * and `RUN` over `ACL_WORKFLOW` allows the `RunWf`, `DeleteWfRun`, `StopWfRun`,
     * and `ResumeWfRun` RPC's.
     */
    RUN = "RUN",
    /**
     * WRITE_METADATA - Allows mutating metadata. For example, `WRITE_METADATA` over `ACL_WORKFLOW` allows
     * mutating `WfSpec`s, and `WRITE_METADATA` over `ACL_TASK` allows mutating `TaskDef`s.
     */
    WRITE_METADATA = "WRITE_METADATA",
    /** ALL_ACTIONS - Allows all actions related to a resource. */
    ALL_ACTIONS = "ALL_ACTIONS",
    UNRECOGNIZED = "UNRECOGNIZED"
}
export declare function aCLActionFromJSON(object: any): ACLAction;
export declare function aCLActionToNumber(object: ACLAction): number;
/**
 * A Principal represents the identity of a client of LittleHorse, whether human or
 * machine. The ACL's on the Principal control what actions the client is allowed
 * to take.
 *
 * A Principal is not scoped to a Tenant; rather, a Principal is scoped to the Cluster
 * and may have access to one or more Tenants.
 */
export interface Principal {
    /**
     * The ID of the Principal. In OAuth for human users, this is the user_id. In
     * OAuth for machine clients, this is the Client ID.
     *
     * mTLS for Principal identification is not yet implemented.
     */
    id: PrincipalId | undefined;
    /** The time at which the Principal was created. */
    createdAt: string | undefined;
    /**
     * Maps a Tenant ID to a list of ACL's that the Principal has permission to
     * execute *within that Tenant*.
     */
    perTenantAcls: {
        [key: string]: ServerACLs;
    };
    /** Sets permissions that this Principal has *for any Tenant* in the LH Cluster. */
    globalAcls: ServerACLs | undefined;
}
export interface Principal_PerTenantAclsEntry {
    key: string;
    value: ServerACLs | undefined;
}
/**
 * A Tenant is a logically isolated environment within LittleHorse. All workflows and
 * associated data (WfSpec, WfRun, TaskDef, TaskRun, NodeRun, etc) are scoped to within
 * a Tenant.
 *
 * Future versions will include quotas on a per-Tenant basis.
 */
export interface Tenant {
    /** The ID of the Tenant. */
    id: TenantId | undefined;
    /** The time at which the Tenant was created. */
    createdAt: string | undefined;
}
/** List of ACL's for LittleHorse */
export interface ServerACLs {
    /** The associated ACL's */
    acls: ServerACL[];
}
/**
 * Represents a specific set of permissions over a specific set of objects
 * in a Tenant. This is a *positive* permission.
 */
export interface ServerACL {
    /** The resource types over which permission is granted. */
    resources: ACLResource[];
    /** The actions that are permitted. */
    allowedActions: ACLAction[];
    /**
     * If set, then only the resources with this exact name are allowed. For example,
     * the `READ` and `RUN` `allowed_actions` over `ACL_TASK` with `name` == `my-task`
     * allows a Task Worker to only execute the `my-task` TaskDef.
     *
     * If `name` and `prefix` are unset, then the ACL applies to all resources of the
     * specified types.
     */
    name?: string | undefined;
    /**
     * If set, then only the resources whose names match this prefix are allowed.
     *
     * If `name` and `prefix` are unset, then the ACL applies to all resources of the
     * specified types.
     */
    prefix?: string | undefined;
}
/**
 * Creates or updates a Principal. If this request would remove admin privileges from the
 * last admin principal (i.e. `ALL_ACTIONS` over `ACL_ALL_RESOURCES` in the `global_acls`),
 * then the RPC throws `FAILED_PRECONDITION`.
 */
export interface PutPrincipalRequest {
    /** The ID of the Principal that we are creating. */
    id: string;
    /** The per-tenant ACL's for the Principal */
    perTenantAcls: {
        [key: string]: ServerACLs;
    };
    /** The ACL's for the principal in all tenants */
    globalAcls: ServerACLs | undefined;
    /**
     * If this is set to false and a `Principal` with the same `id` already exists *and*
     * has different ACL's configured, then the RPC throws `ALREADY_EXISTS`.
     *
     * If this is set to `true`, then the RPC will override hte
     */
    overwrite: boolean;
}
export interface PutPrincipalRequest_PerTenantAclsEntry {
    key: string;
    value: ServerACLs | undefined;
}
/**
 * Deletes a `Principal`. Fails with `FAILED_PRECONDITION` if the specified `Principal` is the last
 * admin `Principal`.
 */
export interface DeletePrincipalRequest {
    /** The ID of the `Principal` to delete. */
    id: PrincipalId | undefined;
}
export interface PutTenantRequest {
    id: string;
}
export declare const Principal: {
    encode(message: Principal, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Principal;
    create(base?: DeepPartial<Principal>): Principal;
    fromPartial(object: DeepPartial<Principal>): Principal;
};
export declare const Principal_PerTenantAclsEntry: {
    encode(message: Principal_PerTenantAclsEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Principal_PerTenantAclsEntry;
    create(base?: DeepPartial<Principal_PerTenantAclsEntry>): Principal_PerTenantAclsEntry;
    fromPartial(object: DeepPartial<Principal_PerTenantAclsEntry>): Principal_PerTenantAclsEntry;
};
export declare const Tenant: {
    encode(message: Tenant, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Tenant;
    create(base?: DeepPartial<Tenant>): Tenant;
    fromPartial(object: DeepPartial<Tenant>): Tenant;
};
export declare const ServerACLs: {
    encode(message: ServerACLs, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ServerACLs;
    create(base?: DeepPartial<ServerACLs>): ServerACLs;
    fromPartial(object: DeepPartial<ServerACLs>): ServerACLs;
};
export declare const ServerACL: {
    encode(message: ServerACL, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ServerACL;
    create(base?: DeepPartial<ServerACL>): ServerACL;
    fromPartial(object: DeepPartial<ServerACL>): ServerACL;
};
export declare const PutPrincipalRequest: {
    encode(message: PutPrincipalRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PutPrincipalRequest;
    create(base?: DeepPartial<PutPrincipalRequest>): PutPrincipalRequest;
    fromPartial(object: DeepPartial<PutPrincipalRequest>): PutPrincipalRequest;
};
export declare const PutPrincipalRequest_PerTenantAclsEntry: {
    encode(message: PutPrincipalRequest_PerTenantAclsEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PutPrincipalRequest_PerTenantAclsEntry;
    create(base?: DeepPartial<PutPrincipalRequest_PerTenantAclsEntry>): PutPrincipalRequest_PerTenantAclsEntry;
    fromPartial(object: DeepPartial<PutPrincipalRequest_PerTenantAclsEntry>): PutPrincipalRequest_PerTenantAclsEntry;
};
export declare const DeletePrincipalRequest: {
    encode(message: DeletePrincipalRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DeletePrincipalRequest;
    create(base?: DeepPartial<DeletePrincipalRequest>): DeletePrincipalRequest;
    fromPartial(object: DeepPartial<DeletePrincipalRequest>): DeletePrincipalRequest;
};
export declare const PutTenantRequest: {
    encode(message: PutTenantRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PutTenantRequest;
    create(base?: DeepPartial<PutTenantRequest>): PutTenantRequest;
    fromPartial(object: DeepPartial<PutTenantRequest>): PutTenantRequest;
};
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
type DeepPartial<T> = T extends Builtin ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
export {};
//# sourceMappingURL=acls.d.ts.map