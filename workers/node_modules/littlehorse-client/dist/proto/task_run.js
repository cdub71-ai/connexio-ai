"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.178.0
//   protoc               v4.23.4
// source: task_run.proto
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LHTaskException = exports.LHTaskError = exports.TaskNodeReference = exports.TaskRunSource = exports.TaskAttempt = exports.VarNameAndVal = exports.TaskRun = void 0;
/* eslint-disable */
const minimal_1 = __importDefault(require("protobufjs/minimal"));
const common_enums_1 = require("./common_enums");
const common_wfspec_1 = require("./common_wfspec");
const timestamp_1 = require("./google/protobuf/timestamp");
const object_id_1 = require("./object_id");
const user_tasks_1 = require("./user_tasks");
const variable_1 = require("./variable");
function createBaseTaskRun() {
    return {
        id: undefined,
        taskDefId: undefined,
        attempts: [],
        inputVariables: [],
        source: undefined,
        scheduledAt: undefined,
        status: common_enums_1.TaskStatus.TASK_SCHEDULED,
        timeoutSeconds: 0,
        totalAttempts: 0,
        exponentialBackoff: undefined,
    };
}
exports.TaskRun = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.id !== undefined) {
            object_id_1.TaskRunId.encode(message.id, writer.uint32(10).fork()).ldelim();
        }
        if (message.taskDefId !== undefined) {
            object_id_1.TaskDefId.encode(message.taskDefId, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.attempts) {
            exports.TaskAttempt.encode(v, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.inputVariables) {
            exports.VarNameAndVal.encode(v, writer.uint32(42).fork()).ldelim();
        }
        if (message.source !== undefined) {
            exports.TaskRunSource.encode(message.source, writer.uint32(50).fork()).ldelim();
        }
        if (message.scheduledAt !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.scheduledAt), writer.uint32(58).fork()).ldelim();
        }
        if (message.status !== common_enums_1.TaskStatus.TASK_SCHEDULED) {
            writer.uint32(64).int32((0, common_enums_1.taskStatusToNumber)(message.status));
        }
        if (message.timeoutSeconds !== 0) {
            writer.uint32(72).int32(message.timeoutSeconds);
        }
        if (message.totalAttempts !== 0) {
            writer.uint32(32).int32(message.totalAttempts);
        }
        if (message.exponentialBackoff !== undefined) {
            common_wfspec_1.ExponentialBackoffRetryPolicy.encode(message.exponentialBackoff, writer.uint32(82).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTaskRun();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.id = object_id_1.TaskRunId.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.taskDefId = object_id_1.TaskDefId.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.attempts.push(exports.TaskAttempt.decode(reader, reader.uint32()));
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.inputVariables.push(exports.VarNameAndVal.decode(reader, reader.uint32()));
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.source = exports.TaskRunSource.decode(reader, reader.uint32());
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.scheduledAt = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 8:
                    if (tag !== 64) {
                        break;
                    }
                    message.status = (0, common_enums_1.taskStatusFromJSON)(reader.int32());
                    continue;
                case 9:
                    if (tag !== 72) {
                        break;
                    }
                    message.timeoutSeconds = reader.int32();
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.totalAttempts = reader.int32();
                    continue;
                case 10:
                    if (tag !== 82) {
                        break;
                    }
                    message.exponentialBackoff = common_wfspec_1.ExponentialBackoffRetryPolicy.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.TaskRun.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBaseTaskRun();
        message.id = (object.id !== undefined && object.id !== null) ? object_id_1.TaskRunId.fromPartial(object.id) : undefined;
        message.taskDefId = (object.taskDefId !== undefined && object.taskDefId !== null)
            ? object_id_1.TaskDefId.fromPartial(object.taskDefId)
            : undefined;
        message.attempts = ((_a = object.attempts) === null || _a === void 0 ? void 0 : _a.map((e) => exports.TaskAttempt.fromPartial(e))) || [];
        message.inputVariables = ((_b = object.inputVariables) === null || _b === void 0 ? void 0 : _b.map((e) => exports.VarNameAndVal.fromPartial(e))) || [];
        message.source = (object.source !== undefined && object.source !== null)
            ? exports.TaskRunSource.fromPartial(object.source)
            : undefined;
        message.scheduledAt = (_c = object.scheduledAt) !== null && _c !== void 0 ? _c : undefined;
        message.status = (_d = object.status) !== null && _d !== void 0 ? _d : common_enums_1.TaskStatus.TASK_SCHEDULED;
        message.timeoutSeconds = (_e = object.timeoutSeconds) !== null && _e !== void 0 ? _e : 0;
        message.totalAttempts = (_f = object.totalAttempts) !== null && _f !== void 0 ? _f : 0;
        message.exponentialBackoff = (object.exponentialBackoff !== undefined && object.exponentialBackoff !== null)
            ? common_wfspec_1.ExponentialBackoffRetryPolicy.fromPartial(object.exponentialBackoff)
            : undefined;
        return message;
    },
};
function createBaseVarNameAndVal() {
    return { varName: "", value: undefined };
}
exports.VarNameAndVal = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.varName !== "") {
            writer.uint32(10).string(message.varName);
        }
        if (message.value !== undefined) {
            variable_1.VariableValue.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVarNameAndVal();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.varName = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = variable_1.VariableValue.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.VarNameAndVal.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseVarNameAndVal();
        message.varName = (_a = object.varName) !== null && _a !== void 0 ? _a : "";
        message.value = (object.value !== undefined && object.value !== null)
            ? variable_1.VariableValue.fromPartial(object.value)
            : undefined;
        return message;
    },
};
function createBaseTaskAttempt() {
    return {
        logOutput: undefined,
        scheduleTime: undefined,
        startTime: undefined,
        endTime: undefined,
        taskWorkerId: "",
        taskWorkerVersion: undefined,
        status: common_enums_1.TaskStatus.TASK_SCHEDULED,
        output: undefined,
        error: undefined,
        exception: undefined,
    };
}
exports.TaskAttempt = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.logOutput !== undefined) {
            variable_1.VariableValue.encode(message.logOutput, writer.uint32(18).fork()).ldelim();
        }
        if (message.scheduleTime !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.scheduleTime), writer.uint32(26).fork()).ldelim();
        }
        if (message.startTime !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.startTime), writer.uint32(34).fork()).ldelim();
        }
        if (message.endTime !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.endTime), writer.uint32(42).fork()).ldelim();
        }
        if (message.taskWorkerId !== "") {
            writer.uint32(58).string(message.taskWorkerId);
        }
        if (message.taskWorkerVersion !== undefined) {
            writer.uint32(66).string(message.taskWorkerVersion);
        }
        if (message.status !== common_enums_1.TaskStatus.TASK_SCHEDULED) {
            writer.uint32(72).int32((0, common_enums_1.taskStatusToNumber)(message.status));
        }
        if (message.output !== undefined) {
            variable_1.VariableValue.encode(message.output, writer.uint32(10).fork()).ldelim();
        }
        if (message.error !== undefined) {
            exports.LHTaskError.encode(message.error, writer.uint32(82).fork()).ldelim();
        }
        if (message.exception !== undefined) {
            exports.LHTaskException.encode(message.exception, writer.uint32(90).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTaskAttempt();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.logOutput = variable_1.VariableValue.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.scheduleTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.startTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.endTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.taskWorkerId = reader.string();
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.taskWorkerVersion = reader.string();
                    continue;
                case 9:
                    if (tag !== 72) {
                        break;
                    }
                    message.status = (0, common_enums_1.taskStatusFromJSON)(reader.int32());
                    continue;
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.output = variable_1.VariableValue.decode(reader, reader.uint32());
                    continue;
                case 10:
                    if (tag !== 82) {
                        break;
                    }
                    message.error = exports.LHTaskError.decode(reader, reader.uint32());
                    continue;
                case 11:
                    if (tag !== 90) {
                        break;
                    }
                    message.exception = exports.LHTaskException.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.TaskAttempt.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBaseTaskAttempt();
        message.logOutput = (object.logOutput !== undefined && object.logOutput !== null)
            ? variable_1.VariableValue.fromPartial(object.logOutput)
            : undefined;
        message.scheduleTime = (_a = object.scheduleTime) !== null && _a !== void 0 ? _a : undefined;
        message.startTime = (_b = object.startTime) !== null && _b !== void 0 ? _b : undefined;
        message.endTime = (_c = object.endTime) !== null && _c !== void 0 ? _c : undefined;
        message.taskWorkerId = (_d = object.taskWorkerId) !== null && _d !== void 0 ? _d : "";
        message.taskWorkerVersion = (_e = object.taskWorkerVersion) !== null && _e !== void 0 ? _e : undefined;
        message.status = (_f = object.status) !== null && _f !== void 0 ? _f : common_enums_1.TaskStatus.TASK_SCHEDULED;
        message.output = (object.output !== undefined && object.output !== null)
            ? variable_1.VariableValue.fromPartial(object.output)
            : undefined;
        message.error = (object.error !== undefined && object.error !== null)
            ? exports.LHTaskError.fromPartial(object.error)
            : undefined;
        message.exception = (object.exception !== undefined && object.exception !== null)
            ? exports.LHTaskException.fromPartial(object.exception)
            : undefined;
        return message;
    },
};
function createBaseTaskRunSource() {
    return { taskNode: undefined, userTaskTrigger: undefined, wfSpecId: undefined };
}
exports.TaskRunSource = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.taskNode !== undefined) {
            exports.TaskNodeReference.encode(message.taskNode, writer.uint32(10).fork()).ldelim();
        }
        if (message.userTaskTrigger !== undefined) {
            user_tasks_1.UserTaskTriggerReference.encode(message.userTaskTrigger, writer.uint32(18).fork()).ldelim();
        }
        if (message.wfSpecId !== undefined) {
            object_id_1.WfSpecId.encode(message.wfSpecId, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTaskRunSource();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.taskNode = exports.TaskNodeReference.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.userTaskTrigger = user_tasks_1.UserTaskTriggerReference.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.wfSpecId = object_id_1.WfSpecId.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.TaskRunSource.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseTaskRunSource();
        message.taskNode = (object.taskNode !== undefined && object.taskNode !== null)
            ? exports.TaskNodeReference.fromPartial(object.taskNode)
            : undefined;
        message.userTaskTrigger = (object.userTaskTrigger !== undefined && object.userTaskTrigger !== null)
            ? user_tasks_1.UserTaskTriggerReference.fromPartial(object.userTaskTrigger)
            : undefined;
        message.wfSpecId = (object.wfSpecId !== undefined && object.wfSpecId !== null)
            ? object_id_1.WfSpecId.fromPartial(object.wfSpecId)
            : undefined;
        return message;
    },
};
function createBaseTaskNodeReference() {
    return { nodeRunId: undefined };
}
exports.TaskNodeReference = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.nodeRunId !== undefined) {
            object_id_1.NodeRunId.encode(message.nodeRunId, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTaskNodeReference();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.nodeRunId = object_id_1.NodeRunId.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.TaskNodeReference.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseTaskNodeReference();
        message.nodeRunId = (object.nodeRunId !== undefined && object.nodeRunId !== null)
            ? object_id_1.NodeRunId.fromPartial(object.nodeRunId)
            : undefined;
        return message;
    },
};
function createBaseLHTaskError() {
    return { type: common_enums_1.LHErrorType.CHILD_FAILURE, message: "" };
}
exports.LHTaskError = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.type !== common_enums_1.LHErrorType.CHILD_FAILURE) {
            writer.uint32(8).int32((0, common_enums_1.lHErrorTypeToNumber)(message.type));
        }
        if (message.message !== "") {
            writer.uint32(18).string(message.message);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLHTaskError();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.type = (0, common_enums_1.lHErrorTypeFromJSON)(reader.int32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.message = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.LHTaskError.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseLHTaskError();
        message.type = (_a = object.type) !== null && _a !== void 0 ? _a : common_enums_1.LHErrorType.CHILD_FAILURE;
        message.message = (_b = object.message) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseLHTaskException() {
    return { name: "", message: "", content: undefined };
}
exports.LHTaskException = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.message !== "") {
            writer.uint32(18).string(message.message);
        }
        if (message.content !== undefined) {
            variable_1.VariableValue.encode(message.content, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLHTaskException();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.message = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.content = variable_1.VariableValue.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.LHTaskException.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseLHTaskException();
        message.name = (_a = object.name) !== null && _a !== void 0 ? _a : "";
        message.message = (_b = object.message) !== null && _b !== void 0 ? _b : "";
        message.content = (object.content !== undefined && object.content !== null)
            ? variable_1.VariableValue.fromPartial(object.content)
            : undefined;
        return message;
    },
};
function toTimestamp(dateStr) {
    const date = new globalThis.Date(dateStr);
    const seconds = Math.trunc(date.getTime() / 1000);
    const nanos = (date.getTime() % 1000) * 1000000;
    return { seconds, nanos };
}
function fromTimestamp(t) {
    let millis = (t.seconds || 0) * 1000;
    millis += (t.nanos || 0) / 1000000;
    return new globalThis.Date(millis).toISOString();
}
//# sourceMappingURL=task_run.js.map