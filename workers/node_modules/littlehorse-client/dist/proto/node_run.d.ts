import _m0 from "protobufjs/minimal";
import { LHStatus } from "./common_enums";
import { ExternalEventDefId, ExternalEventId, NodeRunId, TaskRunId, UserTaskRunId, WfSpecId, WorkflowEventId } from "./object_id";
import { VariableValue } from "./variable";
/**
 * A NodeRun is a running instance of a Node in a ThreadRun. Note that a NodeRun
 * is a Getable object, meaning it can be retried from the LittleHorse grpc API.
 */
export interface NodeRun {
    /**
     * The ID of the NodeRun. Note that the NodeRunId contains the WfRunId, the
     * ThreadRun's number, and the position of the NodeRun within that ThreadRun.
     */
    id: NodeRunId | undefined;
    /**
     * The ID of the WfSpec that this NodeRun is from. This is not _always_ the same
     * as the ThreadRun it belongs to because of the upcoming WfSpec Version Migration
     * feature.
     */
    wfSpecId: WfSpecId | undefined;
    /** A list of all ThreadRun's that ran to handle a failure thrown by this NodeRun. */
    failureHandlerIds: number[];
    /** The status of this NodeRun. */
    status: LHStatus;
    /** The time the ThreadRun arrived at this NodeRun. */
    arrivalTime: string | undefined;
    /** The time the NodeRun was terminated (failed or completed). */
    endTime?: string | undefined;
    /** The name of the ThreadSpec to which this NodeRun belongs. */
    threadSpecName: string;
    /** The name of the Node in the ThreadSpec that this NodeRun belongs to. */
    nodeName: string;
    /**
     * A human-readable error message intended to help developers diagnose WfSpec
     * problems.
     */
    errorMessage?: string | undefined;
    /** A list of Failures thrown by this NodeRun. */
    failures: Failure[];
    /** Denotes a TASK node, which runs a TaskRun. */
    task?: TaskNodeRun | undefined;
    /** An EXTERNAL_EVENT node blocks until an ExternalEvent arrives. */
    externalEvent?: ExternalEventRun | undefined;
    /** An ENTRYPOINT node is the first thing that runs in a ThreadRun. */
    entrypoint?: EntrypointRun | undefined;
    /** An EXIT node completes a ThreadRun. */
    exit?: ExitRun | undefined;
    /** A START_THREAD node starts a child ThreadRun. */
    startThread?: StartThreadRun | undefined;
    /** A WAIT_THREADS node waits for one or more child ThreadRun's to complete. */
    waitThreads?: WaitForThreadsRun | undefined;
    /** A SLEEP node makes the ThreadRun block for a certain amount of time. */
    sleep?: SleepNodeRun | undefined;
    /** A USER_TASK node waits until a human executes some work and reports the result. */
    userTask?: UserTaskNodeRun | undefined;
    /**
     * A START_MULTIPLE_THREADS node iterates over a JSON_ARR variable and spawns a
     * child ThreadRun for each element in the list.
     */
    startMultipleThreads?: StartMultipleThreadsRun | undefined;
    throwEvent?: ThrowEventNodeRun | undefined;
}
/** The sub-node structure for a TASK NodeRun. */
export interface TaskNodeRun {
    /**
     * The ID of the TaskRun. Note that if the ThreadRun was halted when it arrived
     * at this TASK Node, then the task_run_id will be unset.
     */
    taskRunId?: TaskRunId | undefined;
}
export interface ThrowEventNodeRun {
    workflowEventId: WorkflowEventId | undefined;
}
/** The sub-node structure for a USER_TASK NodeRun. */
export interface UserTaskNodeRun {
    /**
     * The ID of the UserTaskRun. Note that if the ThreadRun was halted when it arrived
     * at this USER_TASK node, then the user_task_run_id will be unset.
     */
    userTaskRunId?: UserTaskRunId | undefined;
}
/** The sub-node structure for an ENTRYPOINT NodeRun. Currently Empty. */
export interface EntrypointRun {
}
/**
 * The sub-node structure for an EXIT NodeRun. Currently Empty, will contain info
 * about ThreadRun Outputs once those are added in the future.
 */
export interface ExitRun {
}
/** The sub-node structure for a START_THREAD NodeRun. */
export interface StartThreadRun {
    /**
     * Contains the thread_run_number of the created Child ThreadRun, if it has
     * been created already.
     */
    childThreadId?: number | undefined;
    /** The thread_spec_name of the child thread_run. */
    threadSpecName: string;
}
/**
 * The sub-node structure for a START_MULTIPLE_THREADS NodeRun.
 *
 * Note: the output of this NodeRun, which can be used to mutate Variables,
 * is a JSON_ARR variable containing the ID's of all the child threadRuns.
 */
export interface StartMultipleThreadsRun {
    /** The thread_spec_name of the child thread_runs. */
    threadSpecName: string;
    /** The list of all created child ThreadRun's */
    childThreadIds: number[];
}
/** The sub-node structure for a WAIT_FOR_THREADS NodeRun. */
export interface WaitForThreadsRun {
    /** The threads that are being waited for. */
    threads: WaitForThreadsRun_WaitForThread[];
}
/** The status of a single ThreadRun that we are waiting for. */
export declare enum WaitForThreadsRun_WaitingThreadStatus {
    /** THREAD_IN_PROGRESS - The ThreadRun is in progress (i.e. not COMPLETED nor EXCEPTION nor ERROR) */
    THREAD_IN_PROGRESS = "THREAD_IN_PROGRESS",
    /**
     * THREAD_HANDLING_FAILURE - The ThreadRun failed with some failure, and the FailureHandler is running
     * for that Failure.
     */
    THREAD_HANDLING_FAILURE = "THREAD_HANDLING_FAILURE",
    /**
     * THREAD_COMPLETED_OR_FAILURE_HANDLED - We can mark this ThreadRun as "already waited for", meaning that either:
     * 1. It completed successfully, OR
     * 2. It failed, and the Failure Handler successfully completed
     */
    THREAD_COMPLETED_OR_FAILURE_HANDLED = "THREAD_COMPLETED_OR_FAILURE_HANDLED",
    /**
     * THREAD_UNSUCCESSFUL - The ThreadRun did not complete successfully, and there wasn't a successful
     * run of a Failure Handler for the Failure that was thrown.
     */
    THREAD_UNSUCCESSFUL = "THREAD_UNSUCCESSFUL",
    UNRECOGNIZED = "UNRECOGNIZED"
}
export declare function waitForThreadsRun_WaitingThreadStatusFromJSON(object: any): WaitForThreadsRun_WaitingThreadStatus;
export declare function waitForThreadsRun_WaitingThreadStatusToNumber(object: WaitForThreadsRun_WaitingThreadStatus): number;
/** A 'WaitForThread' structure defines a thread that is being waited for. */
export interface WaitForThreadsRun_WaitForThread {
    /**
     * The time at which the ThreadRun ended (successfully or not). Not set if the ThreadRun
     * is still RUNNING, HALTED, or HALTING.
     */
    threadEndTime?: string | undefined;
    /** The current status of the ThreadRun being waited for. */
    threadStatus: LHStatus;
    /** The number of the ThreadRun being waited for. */
    threadRunNumber: number;
    /**
     * The "waiting status" of this specific thread: whether it's still running,
     * already done, handling a failure, or completely failed.
     */
    waitingStatus: WaitForThreadsRun_WaitingThreadStatus;
    /**
     * If there is a failure on the ThreadRun, and we have a failure handler defined
     * for it, then we will start a failure handler for this threadrun. This field
     * is the id of that threadRun.
     */
    failureHandlerThreadRunId?: number | undefined;
}
/** The sub-node structure for an EXTERNAL_EVENT NodeRun. */
export interface ExternalEventRun {
    /** The ExternalEventDefId that we are waiting for. */
    externalEventDefId: ExternalEventDefId | undefined;
    /** The time that the ExternalEvent arrived. Unset if still waiting. */
    eventTime?: string | undefined;
    /** The ExternalEventId of the ExternalEvent. Unset if still waiting. */
    externalEventId?: ExternalEventId | undefined;
    /** Whether we had a timeout while waiting for the ExternalEvent to come. */
    timedOut: boolean;
}
/** The sub-node structure for a SLEEP NodeRun. */
export interface SleepNodeRun {
    /**
     * The time at which the NodeRun is *SCHEDULED TO* wake up. In rare cases, if
     * the LH Server is back-pressuring clients due to extreme load, the timer
     * event which marks the sleep node as "matured" may come in slightly late.
     */
    maturationTime: string | undefined;
    /** Whether the SleepNodeRun has been matured. */
    matured: boolean;
}
/**
 * Denotes a failure that happened during execution of a NodeRun or the outgoing
 * edges.
 */
export interface Failure {
    /**
     * The name of the failure. LittleHorse has certain built-in failures, all named in
     * UPPER_UNDERSCORE_CASE. Such failures correspond with the `LHStatus.ERROR`.
     *
     * Any Failure named in `kebab-case` is a user-defined business `EXCEPTION`, treated
     * as an `LHStatus.EXCEPTION`.
     */
    failureName: string;
    /** The human-readable message associated with this Failure. */
    message: string;
    /**
     * A user-defined Failure can have a value; for example, in Java an Exception is an
     * Object with arbitrary properties and behaviors.
     *
     * Future versions of LH will allow FailureHandler threads to accept that value as
     * an input variable.
     */
    content?: VariableValue | undefined;
    /** A boolean denoting whether a Failure Handler ThreadRun properly handled the Failure. */
    wasProperlyHandled: boolean;
    /**
     * If there is a defined failure handler for the NodeRun, then this field is set to the
     * id of the failure handler thread run.
     */
    failureHandlerThreadrunId?: number | undefined;
}
export declare const NodeRun: {
    encode(message: NodeRun, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): NodeRun;
    create(base?: DeepPartial<NodeRun>): NodeRun;
    fromPartial(object: DeepPartial<NodeRun>): NodeRun;
};
export declare const TaskNodeRun: {
    encode(message: TaskNodeRun, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): TaskNodeRun;
    create(base?: DeepPartial<TaskNodeRun>): TaskNodeRun;
    fromPartial(object: DeepPartial<TaskNodeRun>): TaskNodeRun;
};
export declare const ThrowEventNodeRun: {
    encode(message: ThrowEventNodeRun, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ThrowEventNodeRun;
    create(base?: DeepPartial<ThrowEventNodeRun>): ThrowEventNodeRun;
    fromPartial(object: DeepPartial<ThrowEventNodeRun>): ThrowEventNodeRun;
};
export declare const UserTaskNodeRun: {
    encode(message: UserTaskNodeRun, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): UserTaskNodeRun;
    create(base?: DeepPartial<UserTaskNodeRun>): UserTaskNodeRun;
    fromPartial(object: DeepPartial<UserTaskNodeRun>): UserTaskNodeRun;
};
export declare const EntrypointRun: {
    encode(_: EntrypointRun, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EntrypointRun;
    create(base?: DeepPartial<EntrypointRun>): EntrypointRun;
    fromPartial(_: DeepPartial<EntrypointRun>): EntrypointRun;
};
export declare const ExitRun: {
    encode(_: ExitRun, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ExitRun;
    create(base?: DeepPartial<ExitRun>): ExitRun;
    fromPartial(_: DeepPartial<ExitRun>): ExitRun;
};
export declare const StartThreadRun: {
    encode(message: StartThreadRun, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): StartThreadRun;
    create(base?: DeepPartial<StartThreadRun>): StartThreadRun;
    fromPartial(object: DeepPartial<StartThreadRun>): StartThreadRun;
};
export declare const StartMultipleThreadsRun: {
    encode(message: StartMultipleThreadsRun, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): StartMultipleThreadsRun;
    create(base?: DeepPartial<StartMultipleThreadsRun>): StartMultipleThreadsRun;
    fromPartial(object: DeepPartial<StartMultipleThreadsRun>): StartMultipleThreadsRun;
};
export declare const WaitForThreadsRun: {
    encode(message: WaitForThreadsRun, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): WaitForThreadsRun;
    create(base?: DeepPartial<WaitForThreadsRun>): WaitForThreadsRun;
    fromPartial(object: DeepPartial<WaitForThreadsRun>): WaitForThreadsRun;
};
export declare const WaitForThreadsRun_WaitForThread: {
    encode(message: WaitForThreadsRun_WaitForThread, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): WaitForThreadsRun_WaitForThread;
    create(base?: DeepPartial<WaitForThreadsRun_WaitForThread>): WaitForThreadsRun_WaitForThread;
    fromPartial(object: DeepPartial<WaitForThreadsRun_WaitForThread>): WaitForThreadsRun_WaitForThread;
};
export declare const ExternalEventRun: {
    encode(message: ExternalEventRun, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ExternalEventRun;
    create(base?: DeepPartial<ExternalEventRun>): ExternalEventRun;
    fromPartial(object: DeepPartial<ExternalEventRun>): ExternalEventRun;
};
export declare const SleepNodeRun: {
    encode(message: SleepNodeRun, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): SleepNodeRun;
    create(base?: DeepPartial<SleepNodeRun>): SleepNodeRun;
    fromPartial(object: DeepPartial<SleepNodeRun>): SleepNodeRun;
};
export declare const Failure: {
    encode(message: Failure, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Failure;
    create(base?: DeepPartial<Failure>): Failure;
    fromPartial(object: DeepPartial<Failure>): Failure;
};
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
type DeepPartial<T> = T extends Builtin ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
export {};
//# sourceMappingURL=node_run.d.ts.map