"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.178.0
//   protoc               v4.23.4
// source: wf_run.proto
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ThreadHaltReason = exports.ManualHalt = exports.Interrupted = exports.ParentHalted = exports.HandlingFailureHaltReason = exports.PendingFailureHandlerHaltReason = exports.PendingInterruptHaltReason = exports.PendingFailureHandler = exports.PendingInterrupt = exports.FailureBeingHandled = exports.ThreadRun = exports.WfRun = exports.threadTypeToNumber = exports.threadTypeFromJSON = exports.ThreadType = void 0;
/* eslint-disable */
const minimal_1 = __importDefault(require("protobufjs/minimal"));
const common_enums_1 = require("./common_enums");
const timestamp_1 = require("./google/protobuf/timestamp");
const object_id_1 = require("./object_id");
/** The type of a ThreadRUn. */
var ThreadType;
(function (ThreadType) {
    /** ENTRYPOINT - The ENTRYPOINT ThreadRun. Exactly one per WfRun. Always has number == 0. */
    ThreadType["ENTRYPOINT"] = "ENTRYPOINT";
    /**
     * CHILD - A ThreadRun explicitly created by another ThreadRun via a START_THREAD or START_MULTIPLE_THREADS
     * NodeRun.
     */
    ThreadType["CHILD"] = "CHILD";
    /** INTERRUPT - A ThreadRun that was created to handle an Interrupt. */
    ThreadType["INTERRUPT"] = "INTERRUPT";
    /** FAILURE_HANDLER - A ThreadRun that was created to handle a Failure. */
    ThreadType["FAILURE_HANDLER"] = "FAILURE_HANDLER";
    ThreadType["UNRECOGNIZED"] = "UNRECOGNIZED";
})(ThreadType || (exports.ThreadType = ThreadType = {}));
function threadTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "ENTRYPOINT":
            return ThreadType.ENTRYPOINT;
        case 1:
        case "CHILD":
            return ThreadType.CHILD;
        case 2:
        case "INTERRUPT":
            return ThreadType.INTERRUPT;
        case 3:
        case "FAILURE_HANDLER":
            return ThreadType.FAILURE_HANDLER;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ThreadType.UNRECOGNIZED;
    }
}
exports.threadTypeFromJSON = threadTypeFromJSON;
function threadTypeToNumber(object) {
    switch (object) {
        case ThreadType.ENTRYPOINT:
            return 0;
        case ThreadType.CHILD:
            return 1;
        case ThreadType.INTERRUPT:
            return 2;
        case ThreadType.FAILURE_HANDLER:
            return 3;
        case ThreadType.UNRECOGNIZED:
        default:
            return -1;
    }
}
exports.threadTypeToNumber = threadTypeToNumber;
function createBaseWfRun() {
    return {
        id: undefined,
        wfSpecId: undefined,
        oldWfSpecVersions: [],
        status: common_enums_1.LHStatus.STARTING,
        greatestThreadrunNumber: 0,
        startTime: undefined,
        endTime: undefined,
        threadRuns: [],
        pendingInterrupts: [],
        pendingFailures: [],
    };
}
exports.WfRun = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.id !== undefined) {
            object_id_1.WfRunId.encode(message.id, writer.uint32(10).fork()).ldelim();
        }
        if (message.wfSpecId !== undefined) {
            object_id_1.WfSpecId.encode(message.wfSpecId, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.oldWfSpecVersions) {
            object_id_1.WfSpecId.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.status !== common_enums_1.LHStatus.STARTING) {
            writer.uint32(32).int32((0, common_enums_1.lHStatusToNumber)(message.status));
        }
        if (message.greatestThreadrunNumber !== 0) {
            writer.uint32(40).int32(message.greatestThreadrunNumber);
        }
        if (message.startTime !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.startTime), writer.uint32(50).fork()).ldelim();
        }
        if (message.endTime !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.endTime), writer.uint32(58).fork()).ldelim();
        }
        for (const v of message.threadRuns) {
            exports.ThreadRun.encode(v, writer.uint32(66).fork()).ldelim();
        }
        for (const v of message.pendingInterrupts) {
            exports.PendingInterrupt.encode(v, writer.uint32(74).fork()).ldelim();
        }
        for (const v of message.pendingFailures) {
            exports.PendingFailureHandler.encode(v, writer.uint32(82).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWfRun();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.id = object_id_1.WfRunId.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.wfSpecId = object_id_1.WfSpecId.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.oldWfSpecVersions.push(object_id_1.WfSpecId.decode(reader, reader.uint32()));
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.status = (0, common_enums_1.lHStatusFromJSON)(reader.int32());
                    continue;
                case 5:
                    if (tag !== 40) {
                        break;
                    }
                    message.greatestThreadrunNumber = reader.int32();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.startTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.endTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.threadRuns.push(exports.ThreadRun.decode(reader, reader.uint32()));
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.pendingInterrupts.push(exports.PendingInterrupt.decode(reader, reader.uint32()));
                    continue;
                case 10:
                    if (tag !== 82) {
                        break;
                    }
                    message.pendingFailures.push(exports.PendingFailureHandler.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.WfRun.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const message = createBaseWfRun();
        message.id = (object.id !== undefined && object.id !== null) ? object_id_1.WfRunId.fromPartial(object.id) : undefined;
        message.wfSpecId = (object.wfSpecId !== undefined && object.wfSpecId !== null)
            ? object_id_1.WfSpecId.fromPartial(object.wfSpecId)
            : undefined;
        message.oldWfSpecVersions = ((_a = object.oldWfSpecVersions) === null || _a === void 0 ? void 0 : _a.map((e) => object_id_1.WfSpecId.fromPartial(e))) || [];
        message.status = (_b = object.status) !== null && _b !== void 0 ? _b : common_enums_1.LHStatus.STARTING;
        message.greatestThreadrunNumber = (_c = object.greatestThreadrunNumber) !== null && _c !== void 0 ? _c : 0;
        message.startTime = (_d = object.startTime) !== null && _d !== void 0 ? _d : undefined;
        message.endTime = (_e = object.endTime) !== null && _e !== void 0 ? _e : undefined;
        message.threadRuns = ((_f = object.threadRuns) === null || _f === void 0 ? void 0 : _f.map((e) => exports.ThreadRun.fromPartial(e))) || [];
        message.pendingInterrupts = ((_g = object.pendingInterrupts) === null || _g === void 0 ? void 0 : _g.map((e) => exports.PendingInterrupt.fromPartial(e))) || [];
        message.pendingFailures = ((_h = object.pendingFailures) === null || _h === void 0 ? void 0 : _h.map((e) => exports.PendingFailureHandler.fromPartial(e))) || [];
        return message;
    },
};
function createBaseThreadRun() {
    return {
        wfSpecId: undefined,
        number: 0,
        status: common_enums_1.LHStatus.STARTING,
        threadSpecName: "",
        startTime: undefined,
        endTime: undefined,
        errorMessage: undefined,
        childThreadIds: [],
        parentThreadId: undefined,
        haltReasons: [],
        interruptTriggerId: undefined,
        failureBeingHandled: undefined,
        currentNodePosition: 0,
        handledFailedChildren: [],
        type: ThreadType.ENTRYPOINT,
    };
}
exports.ThreadRun = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.wfSpecId !== undefined) {
            object_id_1.WfSpecId.encode(message.wfSpecId, writer.uint32(10).fork()).ldelim();
        }
        if (message.number !== 0) {
            writer.uint32(16).int32(message.number);
        }
        if (message.status !== common_enums_1.LHStatus.STARTING) {
            writer.uint32(24).int32((0, common_enums_1.lHStatusToNumber)(message.status));
        }
        if (message.threadSpecName !== "") {
            writer.uint32(34).string(message.threadSpecName);
        }
        if (message.startTime !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.startTime), writer.uint32(42).fork()).ldelim();
        }
        if (message.endTime !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.endTime), writer.uint32(50).fork()).ldelim();
        }
        if (message.errorMessage !== undefined) {
            writer.uint32(58).string(message.errorMessage);
        }
        writer.uint32(66).fork();
        for (const v of message.childThreadIds) {
            writer.int32(v);
        }
        writer.ldelim();
        if (message.parentThreadId !== undefined) {
            writer.uint32(72).int32(message.parentThreadId);
        }
        for (const v of message.haltReasons) {
            exports.ThreadHaltReason.encode(v, writer.uint32(82).fork()).ldelim();
        }
        if (message.interruptTriggerId !== undefined) {
            object_id_1.ExternalEventId.encode(message.interruptTriggerId, writer.uint32(90).fork()).ldelim();
        }
        if (message.failureBeingHandled !== undefined) {
            exports.FailureBeingHandled.encode(message.failureBeingHandled, writer.uint32(98).fork()).ldelim();
        }
        if (message.currentNodePosition !== 0) {
            writer.uint32(104).int32(message.currentNodePosition);
        }
        writer.uint32(114).fork();
        for (const v of message.handledFailedChildren) {
            writer.int32(v);
        }
        writer.ldelim();
        if (message.type !== ThreadType.ENTRYPOINT) {
            writer.uint32(120).int32(threadTypeToNumber(message.type));
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseThreadRun();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.wfSpecId = object_id_1.WfSpecId.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.number = reader.int32();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.status = (0, common_enums_1.lHStatusFromJSON)(reader.int32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.threadSpecName = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.startTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.endTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.errorMessage = reader.string();
                    continue;
                case 8:
                    if (tag === 64) {
                        message.childThreadIds.push(reader.int32());
                        continue;
                    }
                    if (tag === 66) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.childThreadIds.push(reader.int32());
                        }
                        continue;
                    }
                    break;
                case 9:
                    if (tag !== 72) {
                        break;
                    }
                    message.parentThreadId = reader.int32();
                    continue;
                case 10:
                    if (tag !== 82) {
                        break;
                    }
                    message.haltReasons.push(exports.ThreadHaltReason.decode(reader, reader.uint32()));
                    continue;
                case 11:
                    if (tag !== 90) {
                        break;
                    }
                    message.interruptTriggerId = object_id_1.ExternalEventId.decode(reader, reader.uint32());
                    continue;
                case 12:
                    if (tag !== 98) {
                        break;
                    }
                    message.failureBeingHandled = exports.FailureBeingHandled.decode(reader, reader.uint32());
                    continue;
                case 13:
                    if (tag !== 104) {
                        break;
                    }
                    message.currentNodePosition = reader.int32();
                    continue;
                case 14:
                    if (tag === 112) {
                        message.handledFailedChildren.push(reader.int32());
                        continue;
                    }
                    if (tag === 114) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.handledFailedChildren.push(reader.int32());
                        }
                        continue;
                    }
                    break;
                case 15:
                    if (tag !== 120) {
                        break;
                    }
                    message.type = threadTypeFromJSON(reader.int32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.ThreadRun.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        const message = createBaseThreadRun();
        message.wfSpecId = (object.wfSpecId !== undefined && object.wfSpecId !== null)
            ? object_id_1.WfSpecId.fromPartial(object.wfSpecId)
            : undefined;
        message.number = (_a = object.number) !== null && _a !== void 0 ? _a : 0;
        message.status = (_b = object.status) !== null && _b !== void 0 ? _b : common_enums_1.LHStatus.STARTING;
        message.threadSpecName = (_c = object.threadSpecName) !== null && _c !== void 0 ? _c : "";
        message.startTime = (_d = object.startTime) !== null && _d !== void 0 ? _d : undefined;
        message.endTime = (_e = object.endTime) !== null && _e !== void 0 ? _e : undefined;
        message.errorMessage = (_f = object.errorMessage) !== null && _f !== void 0 ? _f : undefined;
        message.childThreadIds = ((_g = object.childThreadIds) === null || _g === void 0 ? void 0 : _g.map((e) => e)) || [];
        message.parentThreadId = (_h = object.parentThreadId) !== null && _h !== void 0 ? _h : undefined;
        message.haltReasons = ((_j = object.haltReasons) === null || _j === void 0 ? void 0 : _j.map((e) => exports.ThreadHaltReason.fromPartial(e))) || [];
        message.interruptTriggerId = (object.interruptTriggerId !== undefined && object.interruptTriggerId !== null)
            ? object_id_1.ExternalEventId.fromPartial(object.interruptTriggerId)
            : undefined;
        message.failureBeingHandled = (object.failureBeingHandled !== undefined && object.failureBeingHandled !== null)
            ? exports.FailureBeingHandled.fromPartial(object.failureBeingHandled)
            : undefined;
        message.currentNodePosition = (_k = object.currentNodePosition) !== null && _k !== void 0 ? _k : 0;
        message.handledFailedChildren = ((_l = object.handledFailedChildren) === null || _l === void 0 ? void 0 : _l.map((e) => e)) || [];
        message.type = (_m = object.type) !== null && _m !== void 0 ? _m : ThreadType.ENTRYPOINT;
        return message;
    },
};
function createBaseFailureBeingHandled() {
    return { threadRunNumber: 0, nodeRunPosition: 0, failureNumber: 0 };
}
exports.FailureBeingHandled = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.threadRunNumber !== 0) {
            writer.uint32(8).int32(message.threadRunNumber);
        }
        if (message.nodeRunPosition !== 0) {
            writer.uint32(16).int32(message.nodeRunPosition);
        }
        if (message.failureNumber !== 0) {
            writer.uint32(24).int32(message.failureNumber);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFailureBeingHandled();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.threadRunNumber = reader.int32();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.nodeRunPosition = reader.int32();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.failureNumber = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.FailureBeingHandled.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseFailureBeingHandled();
        message.threadRunNumber = (_a = object.threadRunNumber) !== null && _a !== void 0 ? _a : 0;
        message.nodeRunPosition = (_b = object.nodeRunPosition) !== null && _b !== void 0 ? _b : 0;
        message.failureNumber = (_c = object.failureNumber) !== null && _c !== void 0 ? _c : 0;
        return message;
    },
};
function createBasePendingInterrupt() {
    return { externalEventId: undefined, handlerSpecName: "", interruptedThreadId: 0 };
}
exports.PendingInterrupt = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.externalEventId !== undefined) {
            object_id_1.ExternalEventId.encode(message.externalEventId, writer.uint32(10).fork()).ldelim();
        }
        if (message.handlerSpecName !== "") {
            writer.uint32(18).string(message.handlerSpecName);
        }
        if (message.interruptedThreadId !== 0) {
            writer.uint32(24).int32(message.interruptedThreadId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePendingInterrupt();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.externalEventId = object_id_1.ExternalEventId.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.handlerSpecName = reader.string();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.interruptedThreadId = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.PendingInterrupt.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBasePendingInterrupt();
        message.externalEventId = (object.externalEventId !== undefined && object.externalEventId !== null)
            ? object_id_1.ExternalEventId.fromPartial(object.externalEventId)
            : undefined;
        message.handlerSpecName = (_a = object.handlerSpecName) !== null && _a !== void 0 ? _a : "";
        message.interruptedThreadId = (_b = object.interruptedThreadId) !== null && _b !== void 0 ? _b : 0;
        return message;
    },
};
function createBasePendingFailureHandler() {
    return { failedThreadRun: 0, handlerSpecName: "" };
}
exports.PendingFailureHandler = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.failedThreadRun !== 0) {
            writer.uint32(8).int32(message.failedThreadRun);
        }
        if (message.handlerSpecName !== "") {
            writer.uint32(18).string(message.handlerSpecName);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePendingFailureHandler();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.failedThreadRun = reader.int32();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.handlerSpecName = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.PendingFailureHandler.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBasePendingFailureHandler();
        message.failedThreadRun = (_a = object.failedThreadRun) !== null && _a !== void 0 ? _a : 0;
        message.handlerSpecName = (_b = object.handlerSpecName) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBasePendingInterruptHaltReason() {
    return { externalEventId: undefined };
}
exports.PendingInterruptHaltReason = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.externalEventId !== undefined) {
            object_id_1.ExternalEventId.encode(message.externalEventId, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePendingInterruptHaltReason();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.externalEventId = object_id_1.ExternalEventId.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.PendingInterruptHaltReason.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBasePendingInterruptHaltReason();
        message.externalEventId = (object.externalEventId !== undefined && object.externalEventId !== null)
            ? object_id_1.ExternalEventId.fromPartial(object.externalEventId)
            : undefined;
        return message;
    },
};
function createBasePendingFailureHandlerHaltReason() {
    return { nodeRunPosition: 0 };
}
exports.PendingFailureHandlerHaltReason = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.nodeRunPosition !== 0) {
            writer.uint32(8).int32(message.nodeRunPosition);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePendingFailureHandlerHaltReason();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.nodeRunPosition = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.PendingFailureHandlerHaltReason.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBasePendingFailureHandlerHaltReason();
        message.nodeRunPosition = (_a = object.nodeRunPosition) !== null && _a !== void 0 ? _a : 0;
        return message;
    },
};
function createBaseHandlingFailureHaltReason() {
    return { handlerThreadId: 0 };
}
exports.HandlingFailureHaltReason = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.handlerThreadId !== 0) {
            writer.uint32(8).int32(message.handlerThreadId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHandlingFailureHaltReason();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.handlerThreadId = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.HandlingFailureHaltReason.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseHandlingFailureHaltReason();
        message.handlerThreadId = (_a = object.handlerThreadId) !== null && _a !== void 0 ? _a : 0;
        return message;
    },
};
function createBaseParentHalted() {
    return { parentThreadId: 0 };
}
exports.ParentHalted = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.parentThreadId !== 0) {
            writer.uint32(8).int32(message.parentThreadId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParentHalted();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.parentThreadId = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.ParentHalted.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseParentHalted();
        message.parentThreadId = (_a = object.parentThreadId) !== null && _a !== void 0 ? _a : 0;
        return message;
    },
};
function createBaseInterrupted() {
    return { interruptThreadId: 0 };
}
exports.Interrupted = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.interruptThreadId !== 0) {
            writer.uint32(8).int32(message.interruptThreadId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInterrupted();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.interruptThreadId = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.Interrupted.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseInterrupted();
        message.interruptThreadId = (_a = object.interruptThreadId) !== null && _a !== void 0 ? _a : 0;
        return message;
    },
};
function createBaseManualHalt() {
    return { meaningOfLife: false };
}
exports.ManualHalt = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.meaningOfLife !== false) {
            writer.uint32(1096).bool(message.meaningOfLife);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseManualHalt();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 137:
                    if (tag !== 1096) {
                        break;
                    }
                    message.meaningOfLife = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.ManualHalt.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseManualHalt();
        message.meaningOfLife = (_a = object.meaningOfLife) !== null && _a !== void 0 ? _a : false;
        return message;
    },
};
function createBaseThreadHaltReason() {
    return {
        parentHalted: undefined,
        interrupted: undefined,
        pendingInterrupt: undefined,
        pendingFailure: undefined,
        handlingFailure: undefined,
        manualHalt: undefined,
    };
}
exports.ThreadHaltReason = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.parentHalted !== undefined) {
            exports.ParentHalted.encode(message.parentHalted, writer.uint32(10).fork()).ldelim();
        }
        if (message.interrupted !== undefined) {
            exports.Interrupted.encode(message.interrupted, writer.uint32(18).fork()).ldelim();
        }
        if (message.pendingInterrupt !== undefined) {
            exports.PendingInterruptHaltReason.encode(message.pendingInterrupt, writer.uint32(26).fork()).ldelim();
        }
        if (message.pendingFailure !== undefined) {
            exports.PendingFailureHandlerHaltReason.encode(message.pendingFailure, writer.uint32(34).fork()).ldelim();
        }
        if (message.handlingFailure !== undefined) {
            exports.HandlingFailureHaltReason.encode(message.handlingFailure, writer.uint32(42).fork()).ldelim();
        }
        if (message.manualHalt !== undefined) {
            exports.ManualHalt.encode(message.manualHalt, writer.uint32(50).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseThreadHaltReason();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.parentHalted = exports.ParentHalted.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.interrupted = exports.Interrupted.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.pendingInterrupt = exports.PendingInterruptHaltReason.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.pendingFailure = exports.PendingFailureHandlerHaltReason.decode(reader, reader.uint32());
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.handlingFailure = exports.HandlingFailureHaltReason.decode(reader, reader.uint32());
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.manualHalt = exports.ManualHalt.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.ThreadHaltReason.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseThreadHaltReason();
        message.parentHalted = (object.parentHalted !== undefined && object.parentHalted !== null)
            ? exports.ParentHalted.fromPartial(object.parentHalted)
            : undefined;
        message.interrupted = (object.interrupted !== undefined && object.interrupted !== null)
            ? exports.Interrupted.fromPartial(object.interrupted)
            : undefined;
        message.pendingInterrupt = (object.pendingInterrupt !== undefined && object.pendingInterrupt !== null)
            ? exports.PendingInterruptHaltReason.fromPartial(object.pendingInterrupt)
            : undefined;
        message.pendingFailure = (object.pendingFailure !== undefined && object.pendingFailure !== null)
            ? exports.PendingFailureHandlerHaltReason.fromPartial(object.pendingFailure)
            : undefined;
        message.handlingFailure = (object.handlingFailure !== undefined && object.handlingFailure !== null)
            ? exports.HandlingFailureHaltReason.fromPartial(object.handlingFailure)
            : undefined;
        message.manualHalt = (object.manualHalt !== undefined && object.manualHalt !== null)
            ? exports.ManualHalt.fromPartial(object.manualHalt)
            : undefined;
        return message;
    },
};
function toTimestamp(dateStr) {
    const date = new globalThis.Date(dateStr);
    const seconds = Math.trunc(date.getTime() / 1000);
    const nanos = (date.getTime() % 1000) * 1000000;
    return { seconds, nanos };
}
function fromTimestamp(t) {
    let millis = (t.seconds || 0) * 1000;
    millis += (t.nanos || 0) / 1000000;
    return new globalThis.Date(millis).toISOString();
}
//# sourceMappingURL=wf_run.js.map