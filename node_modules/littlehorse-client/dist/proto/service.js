"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.178.0
//   protoc               v4.23.4
// source: service.proto
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ListNodeRunsRequest = exports.ExternalEventIdList = exports.SearchExternalEventRequest_ByExtEvtDefNameAndStatusRequest = exports.SearchExternalEventRequest = exports.PrincipalIdList = exports.SearchPrincipalRequest = exports.TenantIdList = exports.SearchTenantRequest = exports.ExternalEventDefIdList = exports.SearchExternalEventDefRequest = exports.WfSpecIdList = exports.SearchWfSpecRequest = exports.UserTaskDefIdList = exports.SearchUserTaskDefRequest = exports.TaskDefIdList = exports.SearchTaskDefRequest = exports.VariableIdList = exports.SearchVariableRequest = exports.UserTaskRunIdList = exports.SearchUserTaskRunRequest = exports.NodeRunIdList = exports.SearchNodeRunRequest = exports.TaskRunIdList = exports.SearchTaskRunRequest = exports.WfRunIdList = exports.SearchWfRunRequest = exports.AwaitWorkflowEventRequest = exports.VariableMatch = exports.RunWfRequest_VariablesEntry = exports.RunWfRequest = exports.DeleteExternalEventDefRequest = exports.DeleteWfSpecRequest = exports.DeleteUserTaskDefRequest = exports.DeleteTaskDefRequest = exports.DeleteWfRunRequest = exports.DeleteExternalEventRequest = exports.PutExternalEventRequest = exports.PutExternalEventDefRequest = exports.PutUserTaskDefRequest = exports.PutWorkflowEventDefRequest = exports.PutTaskDefRequest = exports.PutWfSpecRequest_ThreadSpecsEntry = exports.PutWfSpecRequest = exports.GetLatestUserTaskDefRequest = exports.searchNodeRunRequest_NodeTypeToNumber = exports.searchNodeRunRequest_NodeTypeFromJSON = exports.SearchNodeRunRequest_NodeType = exports.allowedUpdateTypeToNumber = exports.allowedUpdateTypeFromJSON = exports.AllowedUpdateType = void 0;
exports.LittleHorseDefinition = exports.ServerVersionResponse = exports.GetLatestWfSpecRequest = exports.MigrateWfSpecRequest = exports.TaskRunList = exports.ListTaskRunsRequest = exports.TaskWorkerGroup_TaskWorkersEntry = exports.TaskWorkerGroup = exports.TaskWorkerMetadata = exports.UserTaskRunList = exports.ListUserTaskRunRequest = exports.WfSpecMetrics = exports.TaskDefMetrics = exports.ListWfMetricsResponse = exports.ListWfMetricsRequest = exports.WfSpecMetricsQueryRequest = exports.ListTaskMetricsResponse = exports.ListTaskMetricsRequest = exports.TaskDefMetricsQueryRequest = exports.RescueThreadRunRequest = exports.ResumeWfRunRequest = exports.StopWfRunRequest = exports.ReportTaskRun = exports.PollTaskResponse = exports.ScheduledTask = exports.PollTaskRequest = exports.LHHostInfo = exports.RegisterTaskWorkerResponse = exports.TaskWorkerHeartBeatRequest = exports.RegisterTaskWorkerRequest = exports.ExternalEventList = exports.ListExternalEventsRequest = exports.VariableList = exports.ListVariablesRequest = exports.NodeRunList = void 0;
/* eslint-disable */
const long_1 = __importDefault(require("long"));
const minimal_1 = __importDefault(require("protobufjs/minimal"));
const acls_1 = require("./acls");
const common_enums_1 = require("./common_enums");
const common_wfspec_1 = require("./common_wfspec");
const external_event_1 = require("./external_event");
const empty_1 = require("./google/protobuf/empty");
const timestamp_1 = require("./google/protobuf/timestamp");
const node_run_1 = require("./node_run");
const object_id_1 = require("./object_id");
const task_def_1 = require("./task_def");
const task_run_1 = require("./task_run");
const user_tasks_1 = require("./user_tasks");
const variable_1 = require("./variable");
const wf_run_1 = require("./wf_run");
const wf_spec_1 = require("./wf_spec");
const workflow_event_1 = require("./workflow_event");
/**
 * This enum controls the behavior of a PutWfSpecRequest when a WfSpec with the same
 * name previously exists.
 */
var AllowedUpdateType;
(function (AllowedUpdateType) {
    /**
     * ALL_UPDATES - Allows any update: both minor (revsion) changes and breaking (majorVersion) changes
     * are accepted
     */
    AllowedUpdateType["ALL_UPDATES"] = "ALL_UPDATES";
    /**
     * MINOR_REVISION_UPDATES - Allows only backwards-compatible changes that do not change the required input variables
     * or the searchable variables in the WfSpec.
     */
    AllowedUpdateType["MINOR_REVISION_UPDATES"] = "MINOR_REVISION_UPDATES";
    /** NO_UPDATES - Rejects any changes to the WfSpec. */
    AllowedUpdateType["NO_UPDATES"] = "NO_UPDATES";
    AllowedUpdateType["UNRECOGNIZED"] = "UNRECOGNIZED";
})(AllowedUpdateType || (exports.AllowedUpdateType = AllowedUpdateType = {}));
function allowedUpdateTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "ALL_UPDATES":
            return AllowedUpdateType.ALL_UPDATES;
        case 1:
        case "MINOR_REVISION_UPDATES":
            return AllowedUpdateType.MINOR_REVISION_UPDATES;
        case 2:
        case "NO_UPDATES":
            return AllowedUpdateType.NO_UPDATES;
        case -1:
        case "UNRECOGNIZED":
        default:
            return AllowedUpdateType.UNRECOGNIZED;
    }
}
exports.allowedUpdateTypeFromJSON = allowedUpdateTypeFromJSON;
function allowedUpdateTypeToNumber(object) {
    switch (object) {
        case AllowedUpdateType.ALL_UPDATES:
            return 0;
        case AllowedUpdateType.MINOR_REVISION_UPDATES:
            return 1;
        case AllowedUpdateType.NO_UPDATES:
            return 2;
        case AllowedUpdateType.UNRECOGNIZED:
        default:
            return -1;
    }
}
exports.allowedUpdateTypeToNumber = allowedUpdateTypeToNumber;
/** This enum denotes the type of a NodeRun. */
var SearchNodeRunRequest_NodeType;
(function (SearchNodeRunRequest_NodeType) {
    /** TASK - TASK node schedules a TaskRun */
    SearchNodeRunRequest_NodeType["TASK"] = "TASK";
    /** EXTERNAL_EVENT - EXTERNAL_EVENT blocks the ThreadRun until a specified ExternalEvent arrives */
    SearchNodeRunRequest_NodeType["EXTERNAL_EVENT"] = "EXTERNAL_EVENT";
    /** ENTRYPOINT - ENTRYPOINT kicks off a ThreadRun */
    SearchNodeRunRequest_NodeType["ENTRYPOINT"] = "ENTRYPOINT";
    /** EXIT - EXIT completes a ThreadRun */
    SearchNodeRunRequest_NodeType["EXIT"] = "EXIT";
    /** START_THREAD - START_THREAD creates a Child ThreadRun */
    SearchNodeRunRequest_NodeType["START_THREAD"] = "START_THREAD";
    /** WAIT_THREADS - WAIT_THREADS waits for one or more child ThreadRuns to complete */
    SearchNodeRunRequest_NodeType["WAIT_THREADS"] = "WAIT_THREADS";
    /** SLEEP - SLEEP makes the ThreadRun sleep for a specified time */
    SearchNodeRunRequest_NodeType["SLEEP"] = "SLEEP";
    /** USER_TASK - USER_TASK creates a UserTaskRun and blocks until the UserTaskRun is completed. */
    SearchNodeRunRequest_NodeType["USER_TASK"] = "USER_TASK";
    /** START_MULTIPLE_THREADS - START_MULTIPLE_THREADS iterates over a list and starts a Child Thread for each item */
    SearchNodeRunRequest_NodeType["START_MULTIPLE_THREADS"] = "START_MULTIPLE_THREADS";
    SearchNodeRunRequest_NodeType["UNRECOGNIZED"] = "UNRECOGNIZED";
})(SearchNodeRunRequest_NodeType || (exports.SearchNodeRunRequest_NodeType = SearchNodeRunRequest_NodeType = {}));
function searchNodeRunRequest_NodeTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "TASK":
            return SearchNodeRunRequest_NodeType.TASK;
        case 1:
        case "EXTERNAL_EVENT":
            return SearchNodeRunRequest_NodeType.EXTERNAL_EVENT;
        case 2:
        case "ENTRYPOINT":
            return SearchNodeRunRequest_NodeType.ENTRYPOINT;
        case 3:
        case "EXIT":
            return SearchNodeRunRequest_NodeType.EXIT;
        case 4:
        case "START_THREAD":
            return SearchNodeRunRequest_NodeType.START_THREAD;
        case 5:
        case "WAIT_THREADS":
            return SearchNodeRunRequest_NodeType.WAIT_THREADS;
        case 6:
        case "SLEEP":
            return SearchNodeRunRequest_NodeType.SLEEP;
        case 7:
        case "USER_TASK":
            return SearchNodeRunRequest_NodeType.USER_TASK;
        case 8:
        case "START_MULTIPLE_THREADS":
            return SearchNodeRunRequest_NodeType.START_MULTIPLE_THREADS;
        case -1:
        case "UNRECOGNIZED":
        default:
            return SearchNodeRunRequest_NodeType.UNRECOGNIZED;
    }
}
exports.searchNodeRunRequest_NodeTypeFromJSON = searchNodeRunRequest_NodeTypeFromJSON;
function searchNodeRunRequest_NodeTypeToNumber(object) {
    switch (object) {
        case SearchNodeRunRequest_NodeType.TASK:
            return 0;
        case SearchNodeRunRequest_NodeType.EXTERNAL_EVENT:
            return 1;
        case SearchNodeRunRequest_NodeType.ENTRYPOINT:
            return 2;
        case SearchNodeRunRequest_NodeType.EXIT:
            return 3;
        case SearchNodeRunRequest_NodeType.START_THREAD:
            return 4;
        case SearchNodeRunRequest_NodeType.WAIT_THREADS:
            return 5;
        case SearchNodeRunRequest_NodeType.SLEEP:
            return 6;
        case SearchNodeRunRequest_NodeType.USER_TASK:
            return 7;
        case SearchNodeRunRequest_NodeType.START_MULTIPLE_THREADS:
            return 8;
        case SearchNodeRunRequest_NodeType.UNRECOGNIZED:
        default:
            return -1;
    }
}
exports.searchNodeRunRequest_NodeTypeToNumber = searchNodeRunRequest_NodeTypeToNumber;
function createBaseGetLatestUserTaskDefRequest() {
    return { name: "" };
}
exports.GetLatestUserTaskDefRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetLatestUserTaskDefRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.GetLatestUserTaskDefRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseGetLatestUserTaskDefRequest();
        message.name = (_a = object.name) !== null && _a !== void 0 ? _a : "";
        return message;
    },
};
function createBasePutWfSpecRequest() {
    return {
        name: "",
        threadSpecs: {},
        entrypointThreadName: "",
        retentionPolicy: undefined,
        parentWfSpec: undefined,
        allowedUpdates: AllowedUpdateType.ALL_UPDATES,
    };
}
exports.PutWfSpecRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        Object.entries(message.threadSpecs).forEach(([key, value]) => {
            exports.PutWfSpecRequest_ThreadSpecsEntry.encode({ key: key, value }, writer.uint32(42).fork()).ldelim();
        });
        if (message.entrypointThreadName !== "") {
            writer.uint32(50).string(message.entrypointThreadName);
        }
        if (message.retentionPolicy !== undefined) {
            wf_spec_1.WorkflowRetentionPolicy.encode(message.retentionPolicy, writer.uint32(66).fork()).ldelim();
        }
        if (message.parentWfSpec !== undefined) {
            wf_spec_1.WfSpec_ParentWfSpecReference.encode(message.parentWfSpec, writer.uint32(74).fork()).ldelim();
        }
        if (message.allowedUpdates !== AllowedUpdateType.ALL_UPDATES) {
            writer.uint32(80).int32(allowedUpdateTypeToNumber(message.allowedUpdates));
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePutWfSpecRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    const entry5 = exports.PutWfSpecRequest_ThreadSpecsEntry.decode(reader, reader.uint32());
                    if (entry5.value !== undefined) {
                        message.threadSpecs[entry5.key] = entry5.value;
                    }
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.entrypointThreadName = reader.string();
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.retentionPolicy = wf_spec_1.WorkflowRetentionPolicy.decode(reader, reader.uint32());
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.parentWfSpec = wf_spec_1.WfSpec_ParentWfSpecReference.decode(reader, reader.uint32());
                    continue;
                case 10:
                    if (tag !== 80) {
                        break;
                    }
                    message.allowedUpdates = allowedUpdateTypeFromJSON(reader.int32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.PutWfSpecRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBasePutWfSpecRequest();
        message.name = (_a = object.name) !== null && _a !== void 0 ? _a : "";
        message.threadSpecs = Object.entries((_b = object.threadSpecs) !== null && _b !== void 0 ? _b : {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = wf_spec_1.ThreadSpec.fromPartial(value);
            }
            return acc;
        }, {});
        message.entrypointThreadName = (_c = object.entrypointThreadName) !== null && _c !== void 0 ? _c : "";
        message.retentionPolicy = (object.retentionPolicy !== undefined && object.retentionPolicy !== null)
            ? wf_spec_1.WorkflowRetentionPolicy.fromPartial(object.retentionPolicy)
            : undefined;
        message.parentWfSpec = (object.parentWfSpec !== undefined && object.parentWfSpec !== null)
            ? wf_spec_1.WfSpec_ParentWfSpecReference.fromPartial(object.parentWfSpec)
            : undefined;
        message.allowedUpdates = (_d = object.allowedUpdates) !== null && _d !== void 0 ? _d : AllowedUpdateType.ALL_UPDATES;
        return message;
    },
};
function createBasePutWfSpecRequest_ThreadSpecsEntry() {
    return { key: "", value: undefined };
}
exports.PutWfSpecRequest_ThreadSpecsEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            wf_spec_1.ThreadSpec.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePutWfSpecRequest_ThreadSpecsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = wf_spec_1.ThreadSpec.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.PutWfSpecRequest_ThreadSpecsEntry.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBasePutWfSpecRequest_ThreadSpecsEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value = (object.value !== undefined && object.value !== null)
            ? wf_spec_1.ThreadSpec.fromPartial(object.value)
            : undefined;
        return message;
    },
};
function createBasePutTaskDefRequest() {
    return { name: "", inputVars: [] };
}
exports.PutTaskDefRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        for (const v of message.inputVars) {
            common_wfspec_1.VariableDef.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePutTaskDefRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.inputVars.push(common_wfspec_1.VariableDef.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.PutTaskDefRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBasePutTaskDefRequest();
        message.name = (_a = object.name) !== null && _a !== void 0 ? _a : "";
        message.inputVars = ((_b = object.inputVars) === null || _b === void 0 ? void 0 : _b.map((e) => common_wfspec_1.VariableDef.fromPartial(e))) || [];
        return message;
    },
};
function createBasePutWorkflowEventDefRequest() {
    return { name: "", type: common_enums_1.VariableType.JSON_OBJ };
}
exports.PutWorkflowEventDefRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.type !== common_enums_1.VariableType.JSON_OBJ) {
            writer.uint32(16).int32((0, common_enums_1.variableTypeToNumber)(message.type));
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePutWorkflowEventDefRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.type = (0, common_enums_1.variableTypeFromJSON)(reader.int32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.PutWorkflowEventDefRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBasePutWorkflowEventDefRequest();
        message.name = (_a = object.name) !== null && _a !== void 0 ? _a : "";
        message.type = (_b = object.type) !== null && _b !== void 0 ? _b : common_enums_1.VariableType.JSON_OBJ;
        return message;
    },
};
function createBasePutUserTaskDefRequest() {
    return { name: "", fields: [], description: undefined };
}
exports.PutUserTaskDefRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        for (const v of message.fields) {
            user_tasks_1.UserTaskField.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.description !== undefined) {
            writer.uint32(26).string(message.description);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePutUserTaskDefRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.fields.push(user_tasks_1.UserTaskField.decode(reader, reader.uint32()));
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.description = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.PutUserTaskDefRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBasePutUserTaskDefRequest();
        message.name = (_a = object.name) !== null && _a !== void 0 ? _a : "";
        message.fields = ((_b = object.fields) === null || _b === void 0 ? void 0 : _b.map((e) => user_tasks_1.UserTaskField.fromPartial(e))) || [];
        message.description = (_c = object.description) !== null && _c !== void 0 ? _c : undefined;
        return message;
    },
};
function createBasePutExternalEventDefRequest() {
    return { name: "", retentionPolicy: undefined };
}
exports.PutExternalEventDefRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.retentionPolicy !== undefined) {
            external_event_1.ExternalEventRetentionPolicy.encode(message.retentionPolicy, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePutExternalEventDefRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.retentionPolicy = external_event_1.ExternalEventRetentionPolicy.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.PutExternalEventDefRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBasePutExternalEventDefRequest();
        message.name = (_a = object.name) !== null && _a !== void 0 ? _a : "";
        message.retentionPolicy = (object.retentionPolicy !== undefined && object.retentionPolicy !== null)
            ? external_event_1.ExternalEventRetentionPolicy.fromPartial(object.retentionPolicy)
            : undefined;
        return message;
    },
};
function createBasePutExternalEventRequest() {
    return {
        wfRunId: undefined,
        externalEventDefId: undefined,
        guid: undefined,
        content: undefined,
        threadRunNumber: undefined,
        nodeRunPosition: undefined,
    };
}
exports.PutExternalEventRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.wfRunId !== undefined) {
            object_id_1.WfRunId.encode(message.wfRunId, writer.uint32(10).fork()).ldelim();
        }
        if (message.externalEventDefId !== undefined) {
            object_id_1.ExternalEventDefId.encode(message.externalEventDefId, writer.uint32(18).fork()).ldelim();
        }
        if (message.guid !== undefined) {
            writer.uint32(26).string(message.guid);
        }
        if (message.content !== undefined) {
            variable_1.VariableValue.encode(message.content, writer.uint32(42).fork()).ldelim();
        }
        if (message.threadRunNumber !== undefined) {
            writer.uint32(48).int32(message.threadRunNumber);
        }
        if (message.nodeRunPosition !== undefined) {
            writer.uint32(56).int32(message.nodeRunPosition);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePutExternalEventRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.wfRunId = object_id_1.WfRunId.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.externalEventDefId = object_id_1.ExternalEventDefId.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.guid = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.content = variable_1.VariableValue.decode(reader, reader.uint32());
                    continue;
                case 6:
                    if (tag !== 48) {
                        break;
                    }
                    message.threadRunNumber = reader.int32();
                    continue;
                case 7:
                    if (tag !== 56) {
                        break;
                    }
                    message.nodeRunPosition = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.PutExternalEventRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBasePutExternalEventRequest();
        message.wfRunId = (object.wfRunId !== undefined && object.wfRunId !== null)
            ? object_id_1.WfRunId.fromPartial(object.wfRunId)
            : undefined;
        message.externalEventDefId = (object.externalEventDefId !== undefined && object.externalEventDefId !== null)
            ? object_id_1.ExternalEventDefId.fromPartial(object.externalEventDefId)
            : undefined;
        message.guid = (_a = object.guid) !== null && _a !== void 0 ? _a : undefined;
        message.content = (object.content !== undefined && object.content !== null)
            ? variable_1.VariableValue.fromPartial(object.content)
            : undefined;
        message.threadRunNumber = (_b = object.threadRunNumber) !== null && _b !== void 0 ? _b : undefined;
        message.nodeRunPosition = (_c = object.nodeRunPosition) !== null && _c !== void 0 ? _c : undefined;
        return message;
    },
};
function createBaseDeleteExternalEventRequest() {
    return { id: undefined };
}
exports.DeleteExternalEventRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.id !== undefined) {
            object_id_1.ExternalEventId.encode(message.id, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeleteExternalEventRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.id = object_id_1.ExternalEventId.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.DeleteExternalEventRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseDeleteExternalEventRequest();
        message.id = (object.id !== undefined && object.id !== null) ? object_id_1.ExternalEventId.fromPartial(object.id) : undefined;
        return message;
    },
};
function createBaseDeleteWfRunRequest() {
    return { id: undefined };
}
exports.DeleteWfRunRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.id !== undefined) {
            object_id_1.WfRunId.encode(message.id, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeleteWfRunRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.id = object_id_1.WfRunId.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.DeleteWfRunRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseDeleteWfRunRequest();
        message.id = (object.id !== undefined && object.id !== null) ? object_id_1.WfRunId.fromPartial(object.id) : undefined;
        return message;
    },
};
function createBaseDeleteTaskDefRequest() {
    return { id: undefined };
}
exports.DeleteTaskDefRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.id !== undefined) {
            object_id_1.TaskDefId.encode(message.id, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeleteTaskDefRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.id = object_id_1.TaskDefId.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.DeleteTaskDefRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseDeleteTaskDefRequest();
        message.id = (object.id !== undefined && object.id !== null) ? object_id_1.TaskDefId.fromPartial(object.id) : undefined;
        return message;
    },
};
function createBaseDeleteUserTaskDefRequest() {
    return { id: undefined };
}
exports.DeleteUserTaskDefRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.id !== undefined) {
            object_id_1.UserTaskDefId.encode(message.id, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeleteUserTaskDefRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.id = object_id_1.UserTaskDefId.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.DeleteUserTaskDefRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseDeleteUserTaskDefRequest();
        message.id = (object.id !== undefined && object.id !== null) ? object_id_1.UserTaskDefId.fromPartial(object.id) : undefined;
        return message;
    },
};
function createBaseDeleteWfSpecRequest() {
    return { id: undefined };
}
exports.DeleteWfSpecRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.id !== undefined) {
            object_id_1.WfSpecId.encode(message.id, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeleteWfSpecRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.id = object_id_1.WfSpecId.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.DeleteWfSpecRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseDeleteWfSpecRequest();
        message.id = (object.id !== undefined && object.id !== null) ? object_id_1.WfSpecId.fromPartial(object.id) : undefined;
        return message;
    },
};
function createBaseDeleteExternalEventDefRequest() {
    return { id: undefined };
}
exports.DeleteExternalEventDefRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.id !== undefined) {
            object_id_1.ExternalEventDefId.encode(message.id, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeleteExternalEventDefRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.id = object_id_1.ExternalEventDefId.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.DeleteExternalEventDefRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseDeleteExternalEventDefRequest();
        message.id = (object.id !== undefined && object.id !== null)
            ? object_id_1.ExternalEventDefId.fromPartial(object.id)
            : undefined;
        return message;
    },
};
function createBaseRunWfRequest() {
    return {
        wfSpecName: "",
        majorVersion: undefined,
        revision: undefined,
        variables: {},
        id: undefined,
        parentWfRunId: undefined,
    };
}
exports.RunWfRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.wfSpecName !== "") {
            writer.uint32(10).string(message.wfSpecName);
        }
        if (message.majorVersion !== undefined) {
            writer.uint32(16).int32(message.majorVersion);
        }
        if (message.revision !== undefined) {
            writer.uint32(24).int32(message.revision);
        }
        Object.entries(message.variables).forEach(([key, value]) => {
            exports.RunWfRequest_VariablesEntry.encode({ key: key, value }, writer.uint32(34).fork()).ldelim();
        });
        if (message.id !== undefined) {
            writer.uint32(42).string(message.id);
        }
        if (message.parentWfRunId !== undefined) {
            object_id_1.WfRunId.encode(message.parentWfRunId, writer.uint32(50).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRunWfRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.wfSpecName = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.majorVersion = reader.int32();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.revision = reader.int32();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    const entry4 = exports.RunWfRequest_VariablesEntry.decode(reader, reader.uint32());
                    if (entry4.value !== undefined) {
                        message.variables[entry4.key] = entry4.value;
                    }
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.id = reader.string();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.parentWfRunId = object_id_1.WfRunId.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.RunWfRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseRunWfRequest();
        message.wfSpecName = (_a = object.wfSpecName) !== null && _a !== void 0 ? _a : "";
        message.majorVersion = (_b = object.majorVersion) !== null && _b !== void 0 ? _b : undefined;
        message.revision = (_c = object.revision) !== null && _c !== void 0 ? _c : undefined;
        message.variables = Object.entries((_d = object.variables) !== null && _d !== void 0 ? _d : {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = variable_1.VariableValue.fromPartial(value);
            }
            return acc;
        }, {});
        message.id = (_e = object.id) !== null && _e !== void 0 ? _e : undefined;
        message.parentWfRunId = (object.parentWfRunId !== undefined && object.parentWfRunId !== null)
            ? object_id_1.WfRunId.fromPartial(object.parentWfRunId)
            : undefined;
        return message;
    },
};
function createBaseRunWfRequest_VariablesEntry() {
    return { key: "", value: undefined };
}
exports.RunWfRequest_VariablesEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            variable_1.VariableValue.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRunWfRequest_VariablesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = variable_1.VariableValue.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.RunWfRequest_VariablesEntry.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseRunWfRequest_VariablesEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value = (object.value !== undefined && object.value !== null)
            ? variable_1.VariableValue.fromPartial(object.value)
            : undefined;
        return message;
    },
};
function createBaseVariableMatch() {
    return { varName: "", value: undefined };
}
exports.VariableMatch = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.varName !== "") {
            writer.uint32(10).string(message.varName);
        }
        if (message.value !== undefined) {
            variable_1.VariableValue.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVariableMatch();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.varName = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = variable_1.VariableValue.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.VariableMatch.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseVariableMatch();
        message.varName = (_a = object.varName) !== null && _a !== void 0 ? _a : "";
        message.value = (object.value !== undefined && object.value !== null)
            ? variable_1.VariableValue.fromPartial(object.value)
            : undefined;
        return message;
    },
};
function createBaseAwaitWorkflowEventRequest() {
    return { wfRunId: undefined, eventDefIds: [], workflowEventsToIgnore: [] };
}
exports.AwaitWorkflowEventRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.wfRunId !== undefined) {
            object_id_1.WfRunId.encode(message.wfRunId, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.eventDefIds) {
            object_id_1.WorkflowEventDefId.encode(v, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.workflowEventsToIgnore) {
            object_id_1.WorkflowEventId.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAwaitWorkflowEventRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.wfRunId = object_id_1.WfRunId.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.eventDefIds.push(object_id_1.WorkflowEventDefId.decode(reader, reader.uint32()));
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.workflowEventsToIgnore.push(object_id_1.WorkflowEventId.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.AwaitWorkflowEventRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseAwaitWorkflowEventRequest();
        message.wfRunId = (object.wfRunId !== undefined && object.wfRunId !== null)
            ? object_id_1.WfRunId.fromPartial(object.wfRunId)
            : undefined;
        message.eventDefIds = ((_a = object.eventDefIds) === null || _a === void 0 ? void 0 : _a.map((e) => object_id_1.WorkflowEventDefId.fromPartial(e))) || [];
        message.workflowEventsToIgnore = ((_b = object.workflowEventsToIgnore) === null || _b === void 0 ? void 0 : _b.map((e) => object_id_1.WorkflowEventId.fromPartial(e))) || [];
        return message;
    },
};
function createBaseSearchWfRunRequest() {
    return {
        bookmark: undefined,
        limit: undefined,
        wfSpecName: "",
        wfSpecMajorVersion: undefined,
        wfSpecRevision: undefined,
        status: undefined,
        earliestStart: undefined,
        latestStart: undefined,
        variableFilters: [],
    };
}
exports.SearchWfRunRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.bookmark !== undefined) {
            writer.uint32(10).bytes(message.bookmark);
        }
        if (message.limit !== undefined) {
            writer.uint32(16).int32(message.limit);
        }
        if (message.wfSpecName !== "") {
            writer.uint32(26).string(message.wfSpecName);
        }
        if (message.wfSpecMajorVersion !== undefined) {
            writer.uint32(32).int32(message.wfSpecMajorVersion);
        }
        if (message.wfSpecRevision !== undefined) {
            writer.uint32(40).int32(message.wfSpecRevision);
        }
        if (message.status !== undefined) {
            writer.uint32(48).int32((0, common_enums_1.lHStatusToNumber)(message.status));
        }
        if (message.earliestStart !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.earliestStart), writer.uint32(58).fork()).ldelim();
        }
        if (message.latestStart !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.latestStart), writer.uint32(66).fork()).ldelim();
        }
        for (const v of message.variableFilters) {
            exports.VariableMatch.encode(v, writer.uint32(74).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSearchWfRunRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.bookmark = reader.bytes();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.limit = reader.int32();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.wfSpecName = reader.string();
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.wfSpecMajorVersion = reader.int32();
                    continue;
                case 5:
                    if (tag !== 40) {
                        break;
                    }
                    message.wfSpecRevision = reader.int32();
                    continue;
                case 6:
                    if (tag !== 48) {
                        break;
                    }
                    message.status = (0, common_enums_1.lHStatusFromJSON)(reader.int32());
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.earliestStart = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.latestStart = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.variableFilters.push(exports.VariableMatch.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.SearchWfRunRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const message = createBaseSearchWfRunRequest();
        message.bookmark = (_a = object.bookmark) !== null && _a !== void 0 ? _a : undefined;
        message.limit = (_b = object.limit) !== null && _b !== void 0 ? _b : undefined;
        message.wfSpecName = (_c = object.wfSpecName) !== null && _c !== void 0 ? _c : "";
        message.wfSpecMajorVersion = (_d = object.wfSpecMajorVersion) !== null && _d !== void 0 ? _d : undefined;
        message.wfSpecRevision = (_e = object.wfSpecRevision) !== null && _e !== void 0 ? _e : undefined;
        message.status = (_f = object.status) !== null && _f !== void 0 ? _f : undefined;
        message.earliestStart = (_g = object.earliestStart) !== null && _g !== void 0 ? _g : undefined;
        message.latestStart = (_h = object.latestStart) !== null && _h !== void 0 ? _h : undefined;
        message.variableFilters = ((_j = object.variableFilters) === null || _j === void 0 ? void 0 : _j.map((e) => exports.VariableMatch.fromPartial(e))) || [];
        return message;
    },
};
function createBaseWfRunIdList() {
    return { results: [], bookmark: undefined };
}
exports.WfRunIdList = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.results) {
            object_id_1.WfRunId.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.bookmark !== undefined) {
            writer.uint32(18).bytes(message.bookmark);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWfRunIdList();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.results.push(object_id_1.WfRunId.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.bookmark = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.WfRunIdList.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseWfRunIdList();
        message.results = ((_a = object.results) === null || _a === void 0 ? void 0 : _a.map((e) => object_id_1.WfRunId.fromPartial(e))) || [];
        message.bookmark = (_b = object.bookmark) !== null && _b !== void 0 ? _b : undefined;
        return message;
    },
};
function createBaseSearchTaskRunRequest() {
    return {
        bookmark: undefined,
        limit: undefined,
        taskDefName: "",
        status: undefined,
        earliestStart: undefined,
        latestStart: undefined,
    };
}
exports.SearchTaskRunRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.bookmark !== undefined) {
            writer.uint32(10).bytes(message.bookmark);
        }
        if (message.limit !== undefined) {
            writer.uint32(16).int32(message.limit);
        }
        if (message.taskDefName !== "") {
            writer.uint32(26).string(message.taskDefName);
        }
        if (message.status !== undefined) {
            writer.uint32(32).int32((0, common_enums_1.taskStatusToNumber)(message.status));
        }
        if (message.earliestStart !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.earliestStart), writer.uint32(42).fork()).ldelim();
        }
        if (message.latestStart !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.latestStart), writer.uint32(50).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSearchTaskRunRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.bookmark = reader.bytes();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.limit = reader.int32();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.taskDefName = reader.string();
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.status = (0, common_enums_1.taskStatusFromJSON)(reader.int32());
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.earliestStart = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.latestStart = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.SearchTaskRunRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBaseSearchTaskRunRequest();
        message.bookmark = (_a = object.bookmark) !== null && _a !== void 0 ? _a : undefined;
        message.limit = (_b = object.limit) !== null && _b !== void 0 ? _b : undefined;
        message.taskDefName = (_c = object.taskDefName) !== null && _c !== void 0 ? _c : "";
        message.status = (_d = object.status) !== null && _d !== void 0 ? _d : undefined;
        message.earliestStart = (_e = object.earliestStart) !== null && _e !== void 0 ? _e : undefined;
        message.latestStart = (_f = object.latestStart) !== null && _f !== void 0 ? _f : undefined;
        return message;
    },
};
function createBaseTaskRunIdList() {
    return { results: [], bookmark: undefined };
}
exports.TaskRunIdList = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.results) {
            object_id_1.TaskRunId.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.bookmark !== undefined) {
            writer.uint32(18).bytes(message.bookmark);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTaskRunIdList();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.results.push(object_id_1.TaskRunId.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.bookmark = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.TaskRunIdList.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseTaskRunIdList();
        message.results = ((_a = object.results) === null || _a === void 0 ? void 0 : _a.map((e) => object_id_1.TaskRunId.fromPartial(e))) || [];
        message.bookmark = (_b = object.bookmark) !== null && _b !== void 0 ? _b : undefined;
        return message;
    },
};
function createBaseSearchNodeRunRequest() {
    return {
        bookmark: undefined,
        limit: undefined,
        earliestStart: undefined,
        latestStart: undefined,
        nodeType: SearchNodeRunRequest_NodeType.TASK,
        status: common_enums_1.LHStatus.STARTING,
    };
}
exports.SearchNodeRunRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.bookmark !== undefined) {
            writer.uint32(10).bytes(message.bookmark);
        }
        if (message.limit !== undefined) {
            writer.uint32(16).int32(message.limit);
        }
        if (message.earliestStart !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.earliestStart), writer.uint32(26).fork()).ldelim();
        }
        if (message.latestStart !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.latestStart), writer.uint32(34).fork()).ldelim();
        }
        if (message.nodeType !== SearchNodeRunRequest_NodeType.TASK) {
            writer.uint32(40).int32(searchNodeRunRequest_NodeTypeToNumber(message.nodeType));
        }
        if (message.status !== common_enums_1.LHStatus.STARTING) {
            writer.uint32(48).int32((0, common_enums_1.lHStatusToNumber)(message.status));
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSearchNodeRunRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.bookmark = reader.bytes();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.limit = reader.int32();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.earliestStart = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.latestStart = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 5:
                    if (tag !== 40) {
                        break;
                    }
                    message.nodeType = searchNodeRunRequest_NodeTypeFromJSON(reader.int32());
                    continue;
                case 6:
                    if (tag !== 48) {
                        break;
                    }
                    message.status = (0, common_enums_1.lHStatusFromJSON)(reader.int32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.SearchNodeRunRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBaseSearchNodeRunRequest();
        message.bookmark = (_a = object.bookmark) !== null && _a !== void 0 ? _a : undefined;
        message.limit = (_b = object.limit) !== null && _b !== void 0 ? _b : undefined;
        message.earliestStart = (_c = object.earliestStart) !== null && _c !== void 0 ? _c : undefined;
        message.latestStart = (_d = object.latestStart) !== null && _d !== void 0 ? _d : undefined;
        message.nodeType = (_e = object.nodeType) !== null && _e !== void 0 ? _e : SearchNodeRunRequest_NodeType.TASK;
        message.status = (_f = object.status) !== null && _f !== void 0 ? _f : common_enums_1.LHStatus.STARTING;
        return message;
    },
};
function createBaseNodeRunIdList() {
    return { results: [], bookmark: undefined };
}
exports.NodeRunIdList = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.results) {
            object_id_1.NodeRunId.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.bookmark !== undefined) {
            writer.uint32(18).bytes(message.bookmark);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseNodeRunIdList();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.results.push(object_id_1.NodeRunId.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.bookmark = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.NodeRunIdList.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseNodeRunIdList();
        message.results = ((_a = object.results) === null || _a === void 0 ? void 0 : _a.map((e) => object_id_1.NodeRunId.fromPartial(e))) || [];
        message.bookmark = (_b = object.bookmark) !== null && _b !== void 0 ? _b : undefined;
        return message;
    },
};
function createBaseSearchUserTaskRunRequest() {
    return {
        bookmark: undefined,
        limit: undefined,
        status: undefined,
        userTaskDefName: undefined,
        userId: undefined,
        userGroup: undefined,
        earliestStart: undefined,
        latestStart: undefined,
    };
}
exports.SearchUserTaskRunRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.bookmark !== undefined) {
            writer.uint32(10).bytes(message.bookmark);
        }
        if (message.limit !== undefined) {
            writer.uint32(16).int32(message.limit);
        }
        if (message.status !== undefined) {
            writer.uint32(24).int32((0, user_tasks_1.userTaskRunStatusToNumber)(message.status));
        }
        if (message.userTaskDefName !== undefined) {
            writer.uint32(34).string(message.userTaskDefName);
        }
        if (message.userId !== undefined) {
            writer.uint32(42).string(message.userId);
        }
        if (message.userGroup !== undefined) {
            writer.uint32(50).string(message.userGroup);
        }
        if (message.earliestStart !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.earliestStart), writer.uint32(58).fork()).ldelim();
        }
        if (message.latestStart !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.latestStart), writer.uint32(66).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSearchUserTaskRunRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.bookmark = reader.bytes();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.limit = reader.int32();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.status = (0, user_tasks_1.userTaskRunStatusFromJSON)(reader.int32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.userTaskDefName = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.userId = reader.string();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.userGroup = reader.string();
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.earliestStart = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.latestStart = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.SearchUserTaskRunRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const message = createBaseSearchUserTaskRunRequest();
        message.bookmark = (_a = object.bookmark) !== null && _a !== void 0 ? _a : undefined;
        message.limit = (_b = object.limit) !== null && _b !== void 0 ? _b : undefined;
        message.status = (_c = object.status) !== null && _c !== void 0 ? _c : undefined;
        message.userTaskDefName = (_d = object.userTaskDefName) !== null && _d !== void 0 ? _d : undefined;
        message.userId = (_e = object.userId) !== null && _e !== void 0 ? _e : undefined;
        message.userGroup = (_f = object.userGroup) !== null && _f !== void 0 ? _f : undefined;
        message.earliestStart = (_g = object.earliestStart) !== null && _g !== void 0 ? _g : undefined;
        message.latestStart = (_h = object.latestStart) !== null && _h !== void 0 ? _h : undefined;
        return message;
    },
};
function createBaseUserTaskRunIdList() {
    return { results: [], bookmark: undefined };
}
exports.UserTaskRunIdList = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.results) {
            object_id_1.UserTaskRunId.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.bookmark !== undefined) {
            writer.uint32(18).bytes(message.bookmark);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserTaskRunIdList();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.results.push(object_id_1.UserTaskRunId.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.bookmark = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.UserTaskRunIdList.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseUserTaskRunIdList();
        message.results = ((_a = object.results) === null || _a === void 0 ? void 0 : _a.map((e) => object_id_1.UserTaskRunId.fromPartial(e))) || [];
        message.bookmark = (_b = object.bookmark) !== null && _b !== void 0 ? _b : undefined;
        return message;
    },
};
function createBaseSearchVariableRequest() {
    return {
        bookmark: undefined,
        limit: undefined,
        value: undefined,
        wfSpecMajorVersion: undefined,
        wfSpecRevision: undefined,
        varName: "",
        wfSpecName: "",
    };
}
exports.SearchVariableRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.bookmark !== undefined) {
            writer.uint32(10).bytes(message.bookmark);
        }
        if (message.limit !== undefined) {
            writer.uint32(16).int32(message.limit);
        }
        if (message.value !== undefined) {
            variable_1.VariableValue.encode(message.value, writer.uint32(26).fork()).ldelim();
        }
        if (message.wfSpecMajorVersion !== undefined) {
            writer.uint32(32).int32(message.wfSpecMajorVersion);
        }
        if (message.wfSpecRevision !== undefined) {
            writer.uint32(40).int32(message.wfSpecRevision);
        }
        if (message.varName !== "") {
            writer.uint32(50).string(message.varName);
        }
        if (message.wfSpecName !== "") {
            writer.uint32(58).string(message.wfSpecName);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSearchVariableRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.bookmark = reader.bytes();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.limit = reader.int32();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.value = variable_1.VariableValue.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.wfSpecMajorVersion = reader.int32();
                    continue;
                case 5:
                    if (tag !== 40) {
                        break;
                    }
                    message.wfSpecRevision = reader.int32();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.varName = reader.string();
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.wfSpecName = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.SearchVariableRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBaseSearchVariableRequest();
        message.bookmark = (_a = object.bookmark) !== null && _a !== void 0 ? _a : undefined;
        message.limit = (_b = object.limit) !== null && _b !== void 0 ? _b : undefined;
        message.value = (object.value !== undefined && object.value !== null)
            ? variable_1.VariableValue.fromPartial(object.value)
            : undefined;
        message.wfSpecMajorVersion = (_c = object.wfSpecMajorVersion) !== null && _c !== void 0 ? _c : undefined;
        message.wfSpecRevision = (_d = object.wfSpecRevision) !== null && _d !== void 0 ? _d : undefined;
        message.varName = (_e = object.varName) !== null && _e !== void 0 ? _e : "";
        message.wfSpecName = (_f = object.wfSpecName) !== null && _f !== void 0 ? _f : "";
        return message;
    },
};
function createBaseVariableIdList() {
    return { results: [], bookmark: undefined };
}
exports.VariableIdList = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.results) {
            object_id_1.VariableId.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.bookmark !== undefined) {
            writer.uint32(18).bytes(message.bookmark);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVariableIdList();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.results.push(object_id_1.VariableId.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.bookmark = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.VariableIdList.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseVariableIdList();
        message.results = ((_a = object.results) === null || _a === void 0 ? void 0 : _a.map((e) => object_id_1.VariableId.fromPartial(e))) || [];
        message.bookmark = (_b = object.bookmark) !== null && _b !== void 0 ? _b : undefined;
        return message;
    },
};
function createBaseSearchTaskDefRequest() {
    return { bookmark: undefined, limit: undefined, prefix: undefined };
}
exports.SearchTaskDefRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.bookmark !== undefined) {
            writer.uint32(10).bytes(message.bookmark);
        }
        if (message.limit !== undefined) {
            writer.uint32(16).int32(message.limit);
        }
        if (message.prefix !== undefined) {
            writer.uint32(26).string(message.prefix);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSearchTaskDefRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.bookmark = reader.bytes();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.limit = reader.int32();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.prefix = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.SearchTaskDefRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseSearchTaskDefRequest();
        message.bookmark = (_a = object.bookmark) !== null && _a !== void 0 ? _a : undefined;
        message.limit = (_b = object.limit) !== null && _b !== void 0 ? _b : undefined;
        message.prefix = (_c = object.prefix) !== null && _c !== void 0 ? _c : undefined;
        return message;
    },
};
function createBaseTaskDefIdList() {
    return { results: [], bookmark: undefined };
}
exports.TaskDefIdList = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.results) {
            object_id_1.TaskDefId.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.bookmark !== undefined) {
            writer.uint32(18).bytes(message.bookmark);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTaskDefIdList();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.results.push(object_id_1.TaskDefId.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.bookmark = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.TaskDefIdList.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseTaskDefIdList();
        message.results = ((_a = object.results) === null || _a === void 0 ? void 0 : _a.map((e) => object_id_1.TaskDefId.fromPartial(e))) || [];
        message.bookmark = (_b = object.bookmark) !== null && _b !== void 0 ? _b : undefined;
        return message;
    },
};
function createBaseSearchUserTaskDefRequest() {
    return { bookmark: undefined, limit: undefined, prefix: undefined, name: undefined };
}
exports.SearchUserTaskDefRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.bookmark !== undefined) {
            writer.uint32(10).bytes(message.bookmark);
        }
        if (message.limit !== undefined) {
            writer.uint32(16).int32(message.limit);
        }
        if (message.prefix !== undefined) {
            writer.uint32(26).string(message.prefix);
        }
        if (message.name !== undefined) {
            writer.uint32(34).string(message.name);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSearchUserTaskDefRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.bookmark = reader.bytes();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.limit = reader.int32();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.prefix = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.SearchUserTaskDefRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseSearchUserTaskDefRequest();
        message.bookmark = (_a = object.bookmark) !== null && _a !== void 0 ? _a : undefined;
        message.limit = (_b = object.limit) !== null && _b !== void 0 ? _b : undefined;
        message.prefix = (_c = object.prefix) !== null && _c !== void 0 ? _c : undefined;
        message.name = (_d = object.name) !== null && _d !== void 0 ? _d : undefined;
        return message;
    },
};
function createBaseUserTaskDefIdList() {
    return { results: [], bookmark: undefined };
}
exports.UserTaskDefIdList = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.results) {
            object_id_1.UserTaskDefId.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.bookmark !== undefined) {
            writer.uint32(18).bytes(message.bookmark);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserTaskDefIdList();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.results.push(object_id_1.UserTaskDefId.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.bookmark = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.UserTaskDefIdList.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseUserTaskDefIdList();
        message.results = ((_a = object.results) === null || _a === void 0 ? void 0 : _a.map((e) => object_id_1.UserTaskDefId.fromPartial(e))) || [];
        message.bookmark = (_b = object.bookmark) !== null && _b !== void 0 ? _b : undefined;
        return message;
    },
};
function createBaseSearchWfSpecRequest() {
    return { bookmark: undefined, limit: undefined, name: undefined, prefix: undefined, taskDefName: undefined };
}
exports.SearchWfSpecRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.bookmark !== undefined) {
            writer.uint32(10).bytes(message.bookmark);
        }
        if (message.limit !== undefined) {
            writer.uint32(16).int32(message.limit);
        }
        if (message.name !== undefined) {
            writer.uint32(26).string(message.name);
        }
        if (message.prefix !== undefined) {
            writer.uint32(34).string(message.prefix);
        }
        if (message.taskDefName !== undefined) {
            writer.uint32(42).string(message.taskDefName);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSearchWfSpecRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.bookmark = reader.bytes();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.limit = reader.int32();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.prefix = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.taskDefName = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.SearchWfSpecRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseSearchWfSpecRequest();
        message.bookmark = (_a = object.bookmark) !== null && _a !== void 0 ? _a : undefined;
        message.limit = (_b = object.limit) !== null && _b !== void 0 ? _b : undefined;
        message.name = (_c = object.name) !== null && _c !== void 0 ? _c : undefined;
        message.prefix = (_d = object.prefix) !== null && _d !== void 0 ? _d : undefined;
        message.taskDefName = (_e = object.taskDefName) !== null && _e !== void 0 ? _e : undefined;
        return message;
    },
};
function createBaseWfSpecIdList() {
    return { results: [], bookmark: undefined };
}
exports.WfSpecIdList = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.results) {
            object_id_1.WfSpecId.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.bookmark !== undefined) {
            writer.uint32(18).bytes(message.bookmark);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWfSpecIdList();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.results.push(object_id_1.WfSpecId.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.bookmark = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.WfSpecIdList.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseWfSpecIdList();
        message.results = ((_a = object.results) === null || _a === void 0 ? void 0 : _a.map((e) => object_id_1.WfSpecId.fromPartial(e))) || [];
        message.bookmark = (_b = object.bookmark) !== null && _b !== void 0 ? _b : undefined;
        return message;
    },
};
function createBaseSearchExternalEventDefRequest() {
    return { bookmark: undefined, limit: undefined, prefix: undefined };
}
exports.SearchExternalEventDefRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.bookmark !== undefined) {
            writer.uint32(10).bytes(message.bookmark);
        }
        if (message.limit !== undefined) {
            writer.uint32(16).int32(message.limit);
        }
        if (message.prefix !== undefined) {
            writer.uint32(26).string(message.prefix);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSearchExternalEventDefRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.bookmark = reader.bytes();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.limit = reader.int32();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.prefix = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.SearchExternalEventDefRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseSearchExternalEventDefRequest();
        message.bookmark = (_a = object.bookmark) !== null && _a !== void 0 ? _a : undefined;
        message.limit = (_b = object.limit) !== null && _b !== void 0 ? _b : undefined;
        message.prefix = (_c = object.prefix) !== null && _c !== void 0 ? _c : undefined;
        return message;
    },
};
function createBaseExternalEventDefIdList() {
    return { results: [], bookmark: undefined };
}
exports.ExternalEventDefIdList = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.results) {
            object_id_1.ExternalEventDefId.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.bookmark !== undefined) {
            writer.uint32(18).bytes(message.bookmark);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseExternalEventDefIdList();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.results.push(object_id_1.ExternalEventDefId.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.bookmark = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.ExternalEventDefIdList.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseExternalEventDefIdList();
        message.results = ((_a = object.results) === null || _a === void 0 ? void 0 : _a.map((e) => object_id_1.ExternalEventDefId.fromPartial(e))) || [];
        message.bookmark = (_b = object.bookmark) !== null && _b !== void 0 ? _b : undefined;
        return message;
    },
};
function createBaseSearchTenantRequest() {
    return { limit: undefined, bookmark: undefined };
}
exports.SearchTenantRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.limit !== undefined) {
            writer.uint32(8).int32(message.limit);
        }
        if (message.bookmark !== undefined) {
            writer.uint32(18).bytes(message.bookmark);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSearchTenantRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.limit = reader.int32();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.bookmark = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.SearchTenantRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseSearchTenantRequest();
        message.limit = (_a = object.limit) !== null && _a !== void 0 ? _a : undefined;
        message.bookmark = (_b = object.bookmark) !== null && _b !== void 0 ? _b : undefined;
        return message;
    },
};
function createBaseTenantIdList() {
    return { results: [], bookmark: undefined };
}
exports.TenantIdList = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.results) {
            object_id_1.TenantId.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.bookmark !== undefined) {
            writer.uint32(18).bytes(message.bookmark);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTenantIdList();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.results.push(object_id_1.TenantId.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.bookmark = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.TenantIdList.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseTenantIdList();
        message.results = ((_a = object.results) === null || _a === void 0 ? void 0 : _a.map((e) => object_id_1.TenantId.fromPartial(e))) || [];
        message.bookmark = (_b = object.bookmark) !== null && _b !== void 0 ? _b : undefined;
        return message;
    },
};
function createBaseSearchPrincipalRequest() {
    return {
        bookmark: undefined,
        limit: undefined,
        earliestStart: undefined,
        latestStart: undefined,
        isAdmin: undefined,
        tenantId: undefined,
    };
}
exports.SearchPrincipalRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.bookmark !== undefined) {
            writer.uint32(10).bytes(message.bookmark);
        }
        if (message.limit !== undefined) {
            writer.uint32(16).int32(message.limit);
        }
        if (message.earliestStart !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.earliestStart), writer.uint32(26).fork()).ldelim();
        }
        if (message.latestStart !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.latestStart), writer.uint32(34).fork()).ldelim();
        }
        if (message.isAdmin !== undefined) {
            writer.uint32(40).bool(message.isAdmin);
        }
        if (message.tenantId !== undefined) {
            writer.uint32(50).string(message.tenantId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSearchPrincipalRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.bookmark = reader.bytes();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.limit = reader.int32();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.earliestStart = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.latestStart = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 5:
                    if (tag !== 40) {
                        break;
                    }
                    message.isAdmin = reader.bool();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.tenantId = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.SearchPrincipalRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBaseSearchPrincipalRequest();
        message.bookmark = (_a = object.bookmark) !== null && _a !== void 0 ? _a : undefined;
        message.limit = (_b = object.limit) !== null && _b !== void 0 ? _b : undefined;
        message.earliestStart = (_c = object.earliestStart) !== null && _c !== void 0 ? _c : undefined;
        message.latestStart = (_d = object.latestStart) !== null && _d !== void 0 ? _d : undefined;
        message.isAdmin = (_e = object.isAdmin) !== null && _e !== void 0 ? _e : undefined;
        message.tenantId = (_f = object.tenantId) !== null && _f !== void 0 ? _f : undefined;
        return message;
    },
};
function createBasePrincipalIdList() {
    return { results: [], bookmark: undefined };
}
exports.PrincipalIdList = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.results) {
            object_id_1.PrincipalId.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.bookmark !== undefined) {
            writer.uint32(18).bytes(message.bookmark);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePrincipalIdList();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.results.push(object_id_1.PrincipalId.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.bookmark = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.PrincipalIdList.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBasePrincipalIdList();
        message.results = ((_a = object.results) === null || _a === void 0 ? void 0 : _a.map((e) => object_id_1.PrincipalId.fromPartial(e))) || [];
        message.bookmark = (_b = object.bookmark) !== null && _b !== void 0 ? _b : undefined;
        return message;
    },
};
function createBaseSearchExternalEventRequest() {
    return { bookmark: undefined, limit: undefined, wfRunId: undefined, externalEventDefNameAndStatus: undefined };
}
exports.SearchExternalEventRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.bookmark !== undefined) {
            writer.uint32(10).bytes(message.bookmark);
        }
        if (message.limit !== undefined) {
            writer.uint32(16).int32(message.limit);
        }
        if (message.wfRunId !== undefined) {
            object_id_1.WfRunId.encode(message.wfRunId, writer.uint32(26).fork()).ldelim();
        }
        if (message.externalEventDefNameAndStatus !== undefined) {
            exports.SearchExternalEventRequest_ByExtEvtDefNameAndStatusRequest.encode(message.externalEventDefNameAndStatus, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSearchExternalEventRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.bookmark = reader.bytes();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.limit = reader.int32();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.wfRunId = object_id_1.WfRunId.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.externalEventDefNameAndStatus = exports.SearchExternalEventRequest_ByExtEvtDefNameAndStatusRequest.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.SearchExternalEventRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseSearchExternalEventRequest();
        message.bookmark = (_a = object.bookmark) !== null && _a !== void 0 ? _a : undefined;
        message.limit = (_b = object.limit) !== null && _b !== void 0 ? _b : undefined;
        message.wfRunId = (object.wfRunId !== undefined && object.wfRunId !== null)
            ? object_id_1.WfRunId.fromPartial(object.wfRunId)
            : undefined;
        message.externalEventDefNameAndStatus =
            (object.externalEventDefNameAndStatus !== undefined && object.externalEventDefNameAndStatus !== null)
                ? exports.SearchExternalEventRequest_ByExtEvtDefNameAndStatusRequest.fromPartial(object.externalEventDefNameAndStatus)
                : undefined;
        return message;
    },
};
function createBaseSearchExternalEventRequest_ByExtEvtDefNameAndStatusRequest() {
    return { externalEventDefName: "", isClaimed: undefined };
}
exports.SearchExternalEventRequest_ByExtEvtDefNameAndStatusRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.externalEventDefName !== "") {
            writer.uint32(10).string(message.externalEventDefName);
        }
        if (message.isClaimed !== undefined) {
            writer.uint32(16).bool(message.isClaimed);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSearchExternalEventRequest_ByExtEvtDefNameAndStatusRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.externalEventDefName = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.isClaimed = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.SearchExternalEventRequest_ByExtEvtDefNameAndStatusRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseSearchExternalEventRequest_ByExtEvtDefNameAndStatusRequest();
        message.externalEventDefName = (_a = object.externalEventDefName) !== null && _a !== void 0 ? _a : "";
        message.isClaimed = (_b = object.isClaimed) !== null && _b !== void 0 ? _b : undefined;
        return message;
    },
};
function createBaseExternalEventIdList() {
    return { results: [], bookmark: undefined };
}
exports.ExternalEventIdList = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.results) {
            object_id_1.ExternalEventId.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.bookmark !== undefined) {
            writer.uint32(18).bytes(message.bookmark);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseExternalEventIdList();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.results.push(object_id_1.ExternalEventId.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.bookmark = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.ExternalEventIdList.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseExternalEventIdList();
        message.results = ((_a = object.results) === null || _a === void 0 ? void 0 : _a.map((e) => object_id_1.ExternalEventId.fromPartial(e))) || [];
        message.bookmark = (_b = object.bookmark) !== null && _b !== void 0 ? _b : undefined;
        return message;
    },
};
function createBaseListNodeRunsRequest() {
    return { wfRunId: undefined, threadRunNumber: undefined, bookmark: undefined, limit: undefined };
}
exports.ListNodeRunsRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.wfRunId !== undefined) {
            object_id_1.WfRunId.encode(message.wfRunId, writer.uint32(10).fork()).ldelim();
        }
        if (message.threadRunNumber !== undefined) {
            writer.uint32(16).int32(message.threadRunNumber);
        }
        if (message.bookmark !== undefined) {
            writer.uint32(26).bytes(message.bookmark);
        }
        if (message.limit !== undefined) {
            writer.uint32(32).int32(message.limit);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListNodeRunsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.wfRunId = object_id_1.WfRunId.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.threadRunNumber = reader.int32();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.bookmark = reader.bytes();
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.limit = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.ListNodeRunsRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseListNodeRunsRequest();
        message.wfRunId = (object.wfRunId !== undefined && object.wfRunId !== null)
            ? object_id_1.WfRunId.fromPartial(object.wfRunId)
            : undefined;
        message.threadRunNumber = (_a = object.threadRunNumber) !== null && _a !== void 0 ? _a : undefined;
        message.bookmark = (_b = object.bookmark) !== null && _b !== void 0 ? _b : undefined;
        message.limit = (_c = object.limit) !== null && _c !== void 0 ? _c : undefined;
        return message;
    },
};
function createBaseNodeRunList() {
    return { results: [], bookmark: undefined };
}
exports.NodeRunList = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.results) {
            node_run_1.NodeRun.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.bookmark !== undefined) {
            writer.uint32(18).bytes(message.bookmark);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseNodeRunList();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.results.push(node_run_1.NodeRun.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.bookmark = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.NodeRunList.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseNodeRunList();
        message.results = ((_a = object.results) === null || _a === void 0 ? void 0 : _a.map((e) => node_run_1.NodeRun.fromPartial(e))) || [];
        message.bookmark = (_b = object.bookmark) !== null && _b !== void 0 ? _b : undefined;
        return message;
    },
};
function createBaseListVariablesRequest() {
    return { wfRunId: undefined };
}
exports.ListVariablesRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.wfRunId !== undefined) {
            object_id_1.WfRunId.encode(message.wfRunId, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListVariablesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.wfRunId = object_id_1.WfRunId.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.ListVariablesRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseListVariablesRequest();
        message.wfRunId = (object.wfRunId !== undefined && object.wfRunId !== null)
            ? object_id_1.WfRunId.fromPartial(object.wfRunId)
            : undefined;
        return message;
    },
};
function createBaseVariableList() {
    return { results: [] };
}
exports.VariableList = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.results) {
            variable_1.Variable.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVariableList();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.results.push(variable_1.Variable.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.VariableList.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseVariableList();
        message.results = ((_a = object.results) === null || _a === void 0 ? void 0 : _a.map((e) => variable_1.Variable.fromPartial(e))) || [];
        return message;
    },
};
function createBaseListExternalEventsRequest() {
    return { wfRunId: undefined };
}
exports.ListExternalEventsRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.wfRunId !== undefined) {
            object_id_1.WfRunId.encode(message.wfRunId, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListExternalEventsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.wfRunId = object_id_1.WfRunId.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.ListExternalEventsRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseListExternalEventsRequest();
        message.wfRunId = (object.wfRunId !== undefined && object.wfRunId !== null)
            ? object_id_1.WfRunId.fromPartial(object.wfRunId)
            : undefined;
        return message;
    },
};
function createBaseExternalEventList() {
    return { results: [] };
}
exports.ExternalEventList = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.results) {
            external_event_1.ExternalEvent.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseExternalEventList();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.results.push(external_event_1.ExternalEvent.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.ExternalEventList.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseExternalEventList();
        message.results = ((_a = object.results) === null || _a === void 0 ? void 0 : _a.map((e) => external_event_1.ExternalEvent.fromPartial(e))) || [];
        return message;
    },
};
function createBaseRegisterTaskWorkerRequest() {
    return { taskWorkerId: "", taskDefId: undefined, listenerName: "" };
}
exports.RegisterTaskWorkerRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.taskWorkerId !== "") {
            writer.uint32(10).string(message.taskWorkerId);
        }
        if (message.taskDefId !== undefined) {
            object_id_1.TaskDefId.encode(message.taskDefId, writer.uint32(18).fork()).ldelim();
        }
        if (message.listenerName !== "") {
            writer.uint32(26).string(message.listenerName);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRegisterTaskWorkerRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.taskWorkerId = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.taskDefId = object_id_1.TaskDefId.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.listenerName = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.RegisterTaskWorkerRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseRegisterTaskWorkerRequest();
        message.taskWorkerId = (_a = object.taskWorkerId) !== null && _a !== void 0 ? _a : "";
        message.taskDefId = (object.taskDefId !== undefined && object.taskDefId !== null)
            ? object_id_1.TaskDefId.fromPartial(object.taskDefId)
            : undefined;
        message.listenerName = (_b = object.listenerName) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseTaskWorkerHeartBeatRequest() {
    return { clientId: "", taskDefId: undefined, listenerName: "" };
}
exports.TaskWorkerHeartBeatRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.clientId !== "") {
            writer.uint32(10).string(message.clientId);
        }
        if (message.taskDefId !== undefined) {
            object_id_1.TaskDefId.encode(message.taskDefId, writer.uint32(18).fork()).ldelim();
        }
        if (message.listenerName !== "") {
            writer.uint32(26).string(message.listenerName);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTaskWorkerHeartBeatRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.clientId = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.taskDefId = object_id_1.TaskDefId.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.listenerName = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.TaskWorkerHeartBeatRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseTaskWorkerHeartBeatRequest();
        message.clientId = (_a = object.clientId) !== null && _a !== void 0 ? _a : "";
        message.taskDefId = (object.taskDefId !== undefined && object.taskDefId !== null)
            ? object_id_1.TaskDefId.fromPartial(object.taskDefId)
            : undefined;
        message.listenerName = (_b = object.listenerName) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseRegisterTaskWorkerResponse() {
    return { yourHosts: [], isClusterHealthy: undefined };
}
exports.RegisterTaskWorkerResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.yourHosts) {
            exports.LHHostInfo.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.isClusterHealthy !== undefined) {
            writer.uint32(16).bool(message.isClusterHealthy);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRegisterTaskWorkerResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.yourHosts.push(exports.LHHostInfo.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.isClusterHealthy = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.RegisterTaskWorkerResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseRegisterTaskWorkerResponse();
        message.yourHosts = ((_a = object.yourHosts) === null || _a === void 0 ? void 0 : _a.map((e) => exports.LHHostInfo.fromPartial(e))) || [];
        message.isClusterHealthy = (_b = object.isClusterHealthy) !== null && _b !== void 0 ? _b : undefined;
        return message;
    },
};
function createBaseLHHostInfo() {
    return { host: "", port: 0 };
}
exports.LHHostInfo = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.host !== "") {
            writer.uint32(10).string(message.host);
        }
        if (message.port !== 0) {
            writer.uint32(16).int32(message.port);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLHHostInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.host = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.port = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.LHHostInfo.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseLHHostInfo();
        message.host = (_a = object.host) !== null && _a !== void 0 ? _a : "";
        message.port = (_b = object.port) !== null && _b !== void 0 ? _b : 0;
        return message;
    },
};
function createBasePollTaskRequest() {
    return { taskDefId: undefined, clientId: "", taskWorkerVersion: undefined };
}
exports.PollTaskRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.taskDefId !== undefined) {
            object_id_1.TaskDefId.encode(message.taskDefId, writer.uint32(10).fork()).ldelim();
        }
        if (message.clientId !== "") {
            writer.uint32(18).string(message.clientId);
        }
        if (message.taskWorkerVersion !== undefined) {
            writer.uint32(26).string(message.taskWorkerVersion);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePollTaskRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.taskDefId = object_id_1.TaskDefId.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.clientId = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.taskWorkerVersion = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.PollTaskRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBasePollTaskRequest();
        message.taskDefId = (object.taskDefId !== undefined && object.taskDefId !== null)
            ? object_id_1.TaskDefId.fromPartial(object.taskDefId)
            : undefined;
        message.clientId = (_a = object.clientId) !== null && _a !== void 0 ? _a : "";
        message.taskWorkerVersion = (_b = object.taskWorkerVersion) !== null && _b !== void 0 ? _b : undefined;
        return message;
    },
};
function createBaseScheduledTask() {
    return {
        taskRunId: undefined,
        taskDefId: undefined,
        attemptNumber: 0,
        variables: [],
        createdAt: undefined,
        source: undefined,
    };
}
exports.ScheduledTask = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.taskRunId !== undefined) {
            object_id_1.TaskRunId.encode(message.taskRunId, writer.uint32(10).fork()).ldelim();
        }
        if (message.taskDefId !== undefined) {
            object_id_1.TaskDefId.encode(message.taskDefId, writer.uint32(18).fork()).ldelim();
        }
        if (message.attemptNumber !== 0) {
            writer.uint32(24).int32(message.attemptNumber);
        }
        for (const v of message.variables) {
            task_run_1.VarNameAndVal.encode(v, writer.uint32(34).fork()).ldelim();
        }
        if (message.createdAt !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(42).fork()).ldelim();
        }
        if (message.source !== undefined) {
            task_run_1.TaskRunSource.encode(message.source, writer.uint32(50).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseScheduledTask();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.taskRunId = object_id_1.TaskRunId.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.taskDefId = object_id_1.TaskDefId.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.attemptNumber = reader.int32();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.variables.push(task_run_1.VarNameAndVal.decode(reader, reader.uint32()));
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.createdAt = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.source = task_run_1.TaskRunSource.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.ScheduledTask.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseScheduledTask();
        message.taskRunId = (object.taskRunId !== undefined && object.taskRunId !== null)
            ? object_id_1.TaskRunId.fromPartial(object.taskRunId)
            : undefined;
        message.taskDefId = (object.taskDefId !== undefined && object.taskDefId !== null)
            ? object_id_1.TaskDefId.fromPartial(object.taskDefId)
            : undefined;
        message.attemptNumber = (_a = object.attemptNumber) !== null && _a !== void 0 ? _a : 0;
        message.variables = ((_b = object.variables) === null || _b === void 0 ? void 0 : _b.map((e) => task_run_1.VarNameAndVal.fromPartial(e))) || [];
        message.createdAt = (_c = object.createdAt) !== null && _c !== void 0 ? _c : undefined;
        message.source = (object.source !== undefined && object.source !== null)
            ? task_run_1.TaskRunSource.fromPartial(object.source)
            : undefined;
        return message;
    },
};
function createBasePollTaskResponse() {
    return { result: undefined };
}
exports.PollTaskResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.result !== undefined) {
            exports.ScheduledTask.encode(message.result, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePollTaskResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.result = exports.ScheduledTask.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.PollTaskResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBasePollTaskResponse();
        message.result = (object.result !== undefined && object.result !== null)
            ? exports.ScheduledTask.fromPartial(object.result)
            : undefined;
        return message;
    },
};
function createBaseReportTaskRun() {
    return {
        taskRunId: undefined,
        time: undefined,
        status: common_enums_1.TaskStatus.TASK_SCHEDULED,
        logOutput: undefined,
        attemptNumber: 0,
        output: undefined,
        error: undefined,
        exception: undefined,
    };
}
exports.ReportTaskRun = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.taskRunId !== undefined) {
            object_id_1.TaskRunId.encode(message.taskRunId, writer.uint32(10).fork()).ldelim();
        }
        if (message.time !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.time), writer.uint32(18).fork()).ldelim();
        }
        if (message.status !== common_enums_1.TaskStatus.TASK_SCHEDULED) {
            writer.uint32(24).int32((0, common_enums_1.taskStatusToNumber)(message.status));
        }
        if (message.logOutput !== undefined) {
            variable_1.VariableValue.encode(message.logOutput, writer.uint32(42).fork()).ldelim();
        }
        if (message.attemptNumber !== 0) {
            writer.uint32(48).int32(message.attemptNumber);
        }
        if (message.output !== undefined) {
            variable_1.VariableValue.encode(message.output, writer.uint32(34).fork()).ldelim();
        }
        if (message.error !== undefined) {
            task_run_1.LHTaskError.encode(message.error, writer.uint32(58).fork()).ldelim();
        }
        if (message.exception !== undefined) {
            task_run_1.LHTaskException.encode(message.exception, writer.uint32(66).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseReportTaskRun();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.taskRunId = object_id_1.TaskRunId.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.time = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.status = (0, common_enums_1.taskStatusFromJSON)(reader.int32());
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.logOutput = variable_1.VariableValue.decode(reader, reader.uint32());
                    continue;
                case 6:
                    if (tag !== 48) {
                        break;
                    }
                    message.attemptNumber = reader.int32();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.output = variable_1.VariableValue.decode(reader, reader.uint32());
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.error = task_run_1.LHTaskError.decode(reader, reader.uint32());
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.exception = task_run_1.LHTaskException.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.ReportTaskRun.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseReportTaskRun();
        message.taskRunId = (object.taskRunId !== undefined && object.taskRunId !== null)
            ? object_id_1.TaskRunId.fromPartial(object.taskRunId)
            : undefined;
        message.time = (_a = object.time) !== null && _a !== void 0 ? _a : undefined;
        message.status = (_b = object.status) !== null && _b !== void 0 ? _b : common_enums_1.TaskStatus.TASK_SCHEDULED;
        message.logOutput = (object.logOutput !== undefined && object.logOutput !== null)
            ? variable_1.VariableValue.fromPartial(object.logOutput)
            : undefined;
        message.attemptNumber = (_c = object.attemptNumber) !== null && _c !== void 0 ? _c : 0;
        message.output = (object.output !== undefined && object.output !== null)
            ? variable_1.VariableValue.fromPartial(object.output)
            : undefined;
        message.error = (object.error !== undefined && object.error !== null)
            ? task_run_1.LHTaskError.fromPartial(object.error)
            : undefined;
        message.exception = (object.exception !== undefined && object.exception !== null)
            ? task_run_1.LHTaskException.fromPartial(object.exception)
            : undefined;
        return message;
    },
};
function createBaseStopWfRunRequest() {
    return { wfRunId: undefined, threadRunNumber: 0 };
}
exports.StopWfRunRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.wfRunId !== undefined) {
            object_id_1.WfRunId.encode(message.wfRunId, writer.uint32(10).fork()).ldelim();
        }
        if (message.threadRunNumber !== 0) {
            writer.uint32(16).int32(message.threadRunNumber);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStopWfRunRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.wfRunId = object_id_1.WfRunId.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.threadRunNumber = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.StopWfRunRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseStopWfRunRequest();
        message.wfRunId = (object.wfRunId !== undefined && object.wfRunId !== null)
            ? object_id_1.WfRunId.fromPartial(object.wfRunId)
            : undefined;
        message.threadRunNumber = (_a = object.threadRunNumber) !== null && _a !== void 0 ? _a : 0;
        return message;
    },
};
function createBaseResumeWfRunRequest() {
    return { wfRunId: undefined, threadRunNumber: 0 };
}
exports.ResumeWfRunRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.wfRunId !== undefined) {
            object_id_1.WfRunId.encode(message.wfRunId, writer.uint32(10).fork()).ldelim();
        }
        if (message.threadRunNumber !== 0) {
            writer.uint32(16).int32(message.threadRunNumber);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResumeWfRunRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.wfRunId = object_id_1.WfRunId.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.threadRunNumber = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.ResumeWfRunRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseResumeWfRunRequest();
        message.wfRunId = (object.wfRunId !== undefined && object.wfRunId !== null)
            ? object_id_1.WfRunId.fromPartial(object.wfRunId)
            : undefined;
        message.threadRunNumber = (_a = object.threadRunNumber) !== null && _a !== void 0 ? _a : 0;
        return message;
    },
};
function createBaseRescueThreadRunRequest() {
    return { wfRunId: undefined, threadRunNumber: 0, skipCurrentNode: false };
}
exports.RescueThreadRunRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.wfRunId !== undefined) {
            object_id_1.WfRunId.encode(message.wfRunId, writer.uint32(10).fork()).ldelim();
        }
        if (message.threadRunNumber !== 0) {
            writer.uint32(16).int32(message.threadRunNumber);
        }
        if (message.skipCurrentNode !== false) {
            writer.uint32(24).bool(message.skipCurrentNode);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRescueThreadRunRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.wfRunId = object_id_1.WfRunId.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.threadRunNumber = reader.int32();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.skipCurrentNode = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.RescueThreadRunRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseRescueThreadRunRequest();
        message.wfRunId = (object.wfRunId !== undefined && object.wfRunId !== null)
            ? object_id_1.WfRunId.fromPartial(object.wfRunId)
            : undefined;
        message.threadRunNumber = (_a = object.threadRunNumber) !== null && _a !== void 0 ? _a : 0;
        message.skipCurrentNode = (_b = object.skipCurrentNode) !== null && _b !== void 0 ? _b : false;
        return message;
    },
};
function createBaseTaskDefMetricsQueryRequest() {
    return { windowStart: undefined, windowType: common_enums_1.MetricsWindowLength.MINUTES_5, taskDefName: undefined };
}
exports.TaskDefMetricsQueryRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.windowStart !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.windowStart), writer.uint32(10).fork()).ldelim();
        }
        if (message.windowType !== common_enums_1.MetricsWindowLength.MINUTES_5) {
            writer.uint32(16).int32((0, common_enums_1.metricsWindowLengthToNumber)(message.windowType));
        }
        if (message.taskDefName !== undefined) {
            writer.uint32(26).string(message.taskDefName);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTaskDefMetricsQueryRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.windowStart = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.windowType = (0, common_enums_1.metricsWindowLengthFromJSON)(reader.int32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.taskDefName = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.TaskDefMetricsQueryRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseTaskDefMetricsQueryRequest();
        message.windowStart = (_a = object.windowStart) !== null && _a !== void 0 ? _a : undefined;
        message.windowType = (_b = object.windowType) !== null && _b !== void 0 ? _b : common_enums_1.MetricsWindowLength.MINUTES_5;
        message.taskDefName = (_c = object.taskDefName) !== null && _c !== void 0 ? _c : undefined;
        return message;
    },
};
function createBaseListTaskMetricsRequest() {
    return {
        taskDefId: undefined,
        lastWindowStart: undefined,
        windowLength: common_enums_1.MetricsWindowLength.MINUTES_5,
        numWindows: 0,
    };
}
exports.ListTaskMetricsRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.taskDefId !== undefined) {
            object_id_1.TaskDefId.encode(message.taskDefId, writer.uint32(10).fork()).ldelim();
        }
        if (message.lastWindowStart !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.lastWindowStart), writer.uint32(18).fork()).ldelim();
        }
        if (message.windowLength !== common_enums_1.MetricsWindowLength.MINUTES_5) {
            writer.uint32(24).int32((0, common_enums_1.metricsWindowLengthToNumber)(message.windowLength));
        }
        if (message.numWindows !== 0) {
            writer.uint32(32).int32(message.numWindows);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListTaskMetricsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.taskDefId = object_id_1.TaskDefId.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.lastWindowStart = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.windowLength = (0, common_enums_1.metricsWindowLengthFromJSON)(reader.int32());
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.numWindows = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.ListTaskMetricsRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseListTaskMetricsRequest();
        message.taskDefId = (object.taskDefId !== undefined && object.taskDefId !== null)
            ? object_id_1.TaskDefId.fromPartial(object.taskDefId)
            : undefined;
        message.lastWindowStart = (_a = object.lastWindowStart) !== null && _a !== void 0 ? _a : undefined;
        message.windowLength = (_b = object.windowLength) !== null && _b !== void 0 ? _b : common_enums_1.MetricsWindowLength.MINUTES_5;
        message.numWindows = (_c = object.numWindows) !== null && _c !== void 0 ? _c : 0;
        return message;
    },
};
function createBaseListTaskMetricsResponse() {
    return { results: [] };
}
exports.ListTaskMetricsResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.results) {
            exports.TaskDefMetrics.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListTaskMetricsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.results.push(exports.TaskDefMetrics.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.ListTaskMetricsResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseListTaskMetricsResponse();
        message.results = ((_a = object.results) === null || _a === void 0 ? void 0 : _a.map((e) => exports.TaskDefMetrics.fromPartial(e))) || [];
        return message;
    },
};
function createBaseWfSpecMetricsQueryRequest() {
    return { wfSpecId: undefined, windowStart: undefined, windowLength: common_enums_1.MetricsWindowLength.MINUTES_5 };
}
exports.WfSpecMetricsQueryRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.wfSpecId !== undefined) {
            object_id_1.WfSpecId.encode(message.wfSpecId, writer.uint32(10).fork()).ldelim();
        }
        if (message.windowStart !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.windowStart), writer.uint32(18).fork()).ldelim();
        }
        if (message.windowLength !== common_enums_1.MetricsWindowLength.MINUTES_5) {
            writer.uint32(24).int32((0, common_enums_1.metricsWindowLengthToNumber)(message.windowLength));
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWfSpecMetricsQueryRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.wfSpecId = object_id_1.WfSpecId.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.windowStart = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.windowLength = (0, common_enums_1.metricsWindowLengthFromJSON)(reader.int32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.WfSpecMetricsQueryRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseWfSpecMetricsQueryRequest();
        message.wfSpecId = (object.wfSpecId !== undefined && object.wfSpecId !== null)
            ? object_id_1.WfSpecId.fromPartial(object.wfSpecId)
            : undefined;
        message.windowStart = (_a = object.windowStart) !== null && _a !== void 0 ? _a : undefined;
        message.windowLength = (_b = object.windowLength) !== null && _b !== void 0 ? _b : common_enums_1.MetricsWindowLength.MINUTES_5;
        return message;
    },
};
function createBaseListWfMetricsRequest() {
    return {
        wfSpecId: undefined,
        lastWindowStart: undefined,
        windowLength: common_enums_1.MetricsWindowLength.MINUTES_5,
        numWindows: 0,
    };
}
exports.ListWfMetricsRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.wfSpecId !== undefined) {
            object_id_1.WfSpecId.encode(message.wfSpecId, writer.uint32(10).fork()).ldelim();
        }
        if (message.lastWindowStart !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.lastWindowStart), writer.uint32(18).fork()).ldelim();
        }
        if (message.windowLength !== common_enums_1.MetricsWindowLength.MINUTES_5) {
            writer.uint32(24).int32((0, common_enums_1.metricsWindowLengthToNumber)(message.windowLength));
        }
        if (message.numWindows !== 0) {
            writer.uint32(32).int32(message.numWindows);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListWfMetricsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.wfSpecId = object_id_1.WfSpecId.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.lastWindowStart = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.windowLength = (0, common_enums_1.metricsWindowLengthFromJSON)(reader.int32());
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.numWindows = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.ListWfMetricsRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseListWfMetricsRequest();
        message.wfSpecId = (object.wfSpecId !== undefined && object.wfSpecId !== null)
            ? object_id_1.WfSpecId.fromPartial(object.wfSpecId)
            : undefined;
        message.lastWindowStart = (_a = object.lastWindowStart) !== null && _a !== void 0 ? _a : undefined;
        message.windowLength = (_b = object.windowLength) !== null && _b !== void 0 ? _b : common_enums_1.MetricsWindowLength.MINUTES_5;
        message.numWindows = (_c = object.numWindows) !== null && _c !== void 0 ? _c : 0;
        return message;
    },
};
function createBaseListWfMetricsResponse() {
    return { results: [] };
}
exports.ListWfMetricsResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.results) {
            exports.WfSpecMetrics.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListWfMetricsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.results.push(exports.WfSpecMetrics.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.ListWfMetricsResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseListWfMetricsResponse();
        message.results = ((_a = object.results) === null || _a === void 0 ? void 0 : _a.map((e) => exports.WfSpecMetrics.fromPartial(e))) || [];
        return message;
    },
};
function createBaseTaskDefMetrics() {
    return {
        taskDefId: undefined,
        windowStart: undefined,
        type: common_enums_1.MetricsWindowLength.MINUTES_5,
        scheduleToStartMax: 0,
        scheduleToStartAvg: 0,
        startToCompleteMax: 0,
        startToCompleteAvg: 0,
        totalCompleted: 0,
        totalErrored: 0,
        totalStarted: 0,
        totalScheduled: 0,
    };
}
exports.TaskDefMetrics = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.taskDefId !== undefined) {
            object_id_1.TaskDefId.encode(message.taskDefId, writer.uint32(10).fork()).ldelim();
        }
        if (message.windowStart !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.windowStart), writer.uint32(18).fork()).ldelim();
        }
        if (message.type !== common_enums_1.MetricsWindowLength.MINUTES_5) {
            writer.uint32(24).int32((0, common_enums_1.metricsWindowLengthToNumber)(message.type));
        }
        if (message.scheduleToStartMax !== 0) {
            writer.uint32(32).int64(message.scheduleToStartMax);
        }
        if (message.scheduleToStartAvg !== 0) {
            writer.uint32(40).int64(message.scheduleToStartAvg);
        }
        if (message.startToCompleteMax !== 0) {
            writer.uint32(48).int64(message.startToCompleteMax);
        }
        if (message.startToCompleteAvg !== 0) {
            writer.uint32(56).int64(message.startToCompleteAvg);
        }
        if (message.totalCompleted !== 0) {
            writer.uint32(64).int64(message.totalCompleted);
        }
        if (message.totalErrored !== 0) {
            writer.uint32(72).int64(message.totalErrored);
        }
        if (message.totalStarted !== 0) {
            writer.uint32(80).int64(message.totalStarted);
        }
        if (message.totalScheduled !== 0) {
            writer.uint32(88).int64(message.totalScheduled);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTaskDefMetrics();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.taskDefId = object_id_1.TaskDefId.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.windowStart = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.type = (0, common_enums_1.metricsWindowLengthFromJSON)(reader.int32());
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.scheduleToStartMax = longToNumber(reader.int64());
                    continue;
                case 5:
                    if (tag !== 40) {
                        break;
                    }
                    message.scheduleToStartAvg = longToNumber(reader.int64());
                    continue;
                case 6:
                    if (tag !== 48) {
                        break;
                    }
                    message.startToCompleteMax = longToNumber(reader.int64());
                    continue;
                case 7:
                    if (tag !== 56) {
                        break;
                    }
                    message.startToCompleteAvg = longToNumber(reader.int64());
                    continue;
                case 8:
                    if (tag !== 64) {
                        break;
                    }
                    message.totalCompleted = longToNumber(reader.int64());
                    continue;
                case 9:
                    if (tag !== 72) {
                        break;
                    }
                    message.totalErrored = longToNumber(reader.int64());
                    continue;
                case 10:
                    if (tag !== 80) {
                        break;
                    }
                    message.totalStarted = longToNumber(reader.int64());
                    continue;
                case 11:
                    if (tag !== 88) {
                        break;
                    }
                    message.totalScheduled = longToNumber(reader.int64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.TaskDefMetrics.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const message = createBaseTaskDefMetrics();
        message.taskDefId = (object.taskDefId !== undefined && object.taskDefId !== null)
            ? object_id_1.TaskDefId.fromPartial(object.taskDefId)
            : undefined;
        message.windowStart = (_a = object.windowStart) !== null && _a !== void 0 ? _a : undefined;
        message.type = (_b = object.type) !== null && _b !== void 0 ? _b : common_enums_1.MetricsWindowLength.MINUTES_5;
        message.scheduleToStartMax = (_c = object.scheduleToStartMax) !== null && _c !== void 0 ? _c : 0;
        message.scheduleToStartAvg = (_d = object.scheduleToStartAvg) !== null && _d !== void 0 ? _d : 0;
        message.startToCompleteMax = (_e = object.startToCompleteMax) !== null && _e !== void 0 ? _e : 0;
        message.startToCompleteAvg = (_f = object.startToCompleteAvg) !== null && _f !== void 0 ? _f : 0;
        message.totalCompleted = (_g = object.totalCompleted) !== null && _g !== void 0 ? _g : 0;
        message.totalErrored = (_h = object.totalErrored) !== null && _h !== void 0 ? _h : 0;
        message.totalStarted = (_j = object.totalStarted) !== null && _j !== void 0 ? _j : 0;
        message.totalScheduled = (_k = object.totalScheduled) !== null && _k !== void 0 ? _k : 0;
        return message;
    },
};
function createBaseWfSpecMetrics() {
    return {
        wfSpecId: undefined,
        windowStart: undefined,
        type: common_enums_1.MetricsWindowLength.MINUTES_5,
        totalStarted: 0,
        totalCompleted: 0,
        totalErrored: 0,
        startToCompleteMax: 0,
        startToCompleteAvg: 0,
    };
}
exports.WfSpecMetrics = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.wfSpecId !== undefined) {
            object_id_1.WfSpecId.encode(message.wfSpecId, writer.uint32(10).fork()).ldelim();
        }
        if (message.windowStart !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.windowStart), writer.uint32(18).fork()).ldelim();
        }
        if (message.type !== common_enums_1.MetricsWindowLength.MINUTES_5) {
            writer.uint32(24).int32((0, common_enums_1.metricsWindowLengthToNumber)(message.type));
        }
        if (message.totalStarted !== 0) {
            writer.uint32(32).int64(message.totalStarted);
        }
        if (message.totalCompleted !== 0) {
            writer.uint32(40).int64(message.totalCompleted);
        }
        if (message.totalErrored !== 0) {
            writer.uint32(48).int64(message.totalErrored);
        }
        if (message.startToCompleteMax !== 0) {
            writer.uint32(56).int64(message.startToCompleteMax);
        }
        if (message.startToCompleteAvg !== 0) {
            writer.uint32(64).int64(message.startToCompleteAvg);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWfSpecMetrics();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.wfSpecId = object_id_1.WfSpecId.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.windowStart = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.type = (0, common_enums_1.metricsWindowLengthFromJSON)(reader.int32());
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.totalStarted = longToNumber(reader.int64());
                    continue;
                case 5:
                    if (tag !== 40) {
                        break;
                    }
                    message.totalCompleted = longToNumber(reader.int64());
                    continue;
                case 6:
                    if (tag !== 48) {
                        break;
                    }
                    message.totalErrored = longToNumber(reader.int64());
                    continue;
                case 7:
                    if (tag !== 56) {
                        break;
                    }
                    message.startToCompleteMax = longToNumber(reader.int64());
                    continue;
                case 8:
                    if (tag !== 64) {
                        break;
                    }
                    message.startToCompleteAvg = longToNumber(reader.int64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.WfSpecMetrics.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g;
        const message = createBaseWfSpecMetrics();
        message.wfSpecId = (object.wfSpecId !== undefined && object.wfSpecId !== null)
            ? object_id_1.WfSpecId.fromPartial(object.wfSpecId)
            : undefined;
        message.windowStart = (_a = object.windowStart) !== null && _a !== void 0 ? _a : undefined;
        message.type = (_b = object.type) !== null && _b !== void 0 ? _b : common_enums_1.MetricsWindowLength.MINUTES_5;
        message.totalStarted = (_c = object.totalStarted) !== null && _c !== void 0 ? _c : 0;
        message.totalCompleted = (_d = object.totalCompleted) !== null && _d !== void 0 ? _d : 0;
        message.totalErrored = (_e = object.totalErrored) !== null && _e !== void 0 ? _e : 0;
        message.startToCompleteMax = (_f = object.startToCompleteMax) !== null && _f !== void 0 ? _f : 0;
        message.startToCompleteAvg = (_g = object.startToCompleteAvg) !== null && _g !== void 0 ? _g : 0;
        return message;
    },
};
function createBaseListUserTaskRunRequest() {
    return { wfRunId: undefined };
}
exports.ListUserTaskRunRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.wfRunId !== undefined) {
            object_id_1.WfRunId.encode(message.wfRunId, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListUserTaskRunRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.wfRunId = object_id_1.WfRunId.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.ListUserTaskRunRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseListUserTaskRunRequest();
        message.wfRunId = (object.wfRunId !== undefined && object.wfRunId !== null)
            ? object_id_1.WfRunId.fromPartial(object.wfRunId)
            : undefined;
        return message;
    },
};
function createBaseUserTaskRunList() {
    return { results: [] };
}
exports.UserTaskRunList = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.results) {
            user_tasks_1.UserTaskRun.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserTaskRunList();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.results.push(user_tasks_1.UserTaskRun.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.UserTaskRunList.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseUserTaskRunList();
        message.results = ((_a = object.results) === null || _a === void 0 ? void 0 : _a.map((e) => user_tasks_1.UserTaskRun.fromPartial(e))) || [];
        return message;
    },
};
function createBaseTaskWorkerMetadata() {
    return { taskWorkerId: "", latestHeartbeat: undefined, hosts: [] };
}
exports.TaskWorkerMetadata = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.taskWorkerId !== "") {
            writer.uint32(10).string(message.taskWorkerId);
        }
        if (message.latestHeartbeat !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.latestHeartbeat), writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.hosts) {
            exports.LHHostInfo.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTaskWorkerMetadata();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.taskWorkerId = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.latestHeartbeat = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.hosts.push(exports.LHHostInfo.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.TaskWorkerMetadata.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseTaskWorkerMetadata();
        message.taskWorkerId = (_a = object.taskWorkerId) !== null && _a !== void 0 ? _a : "";
        message.latestHeartbeat = (_b = object.latestHeartbeat) !== null && _b !== void 0 ? _b : undefined;
        message.hosts = ((_c = object.hosts) === null || _c === void 0 ? void 0 : _c.map((e) => exports.LHHostInfo.fromPartial(e))) || [];
        return message;
    },
};
function createBaseTaskWorkerGroup() {
    return { id: undefined, createdAt: undefined, taskWorkers: {} };
}
exports.TaskWorkerGroup = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.id !== undefined) {
            object_id_1.TaskWorkerGroupId.encode(message.id, writer.uint32(10).fork()).ldelim();
        }
        if (message.createdAt !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(18).fork()).ldelim();
        }
        Object.entries(message.taskWorkers).forEach(([key, value]) => {
            exports.TaskWorkerGroup_TaskWorkersEntry.encode({ key: key, value }, writer.uint32(26).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTaskWorkerGroup();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.id = object_id_1.TaskWorkerGroupId.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.createdAt = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    const entry3 = exports.TaskWorkerGroup_TaskWorkersEntry.decode(reader, reader.uint32());
                    if (entry3.value !== undefined) {
                        message.taskWorkers[entry3.key] = entry3.value;
                    }
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.TaskWorkerGroup.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseTaskWorkerGroup();
        message.id = (object.id !== undefined && object.id !== null) ? object_id_1.TaskWorkerGroupId.fromPartial(object.id) : undefined;
        message.createdAt = (_a = object.createdAt) !== null && _a !== void 0 ? _a : undefined;
        message.taskWorkers = Object.entries((_b = object.taskWorkers) !== null && _b !== void 0 ? _b : {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = exports.TaskWorkerMetadata.fromPartial(value);
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseTaskWorkerGroup_TaskWorkersEntry() {
    return { key: "", value: undefined };
}
exports.TaskWorkerGroup_TaskWorkersEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            exports.TaskWorkerMetadata.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTaskWorkerGroup_TaskWorkersEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = exports.TaskWorkerMetadata.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.TaskWorkerGroup_TaskWorkersEntry.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseTaskWorkerGroup_TaskWorkersEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value = (object.value !== undefined && object.value !== null)
            ? exports.TaskWorkerMetadata.fromPartial(object.value)
            : undefined;
        return message;
    },
};
function createBaseListTaskRunsRequest() {
    return { wfRunId: undefined };
}
exports.ListTaskRunsRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.wfRunId !== undefined) {
            object_id_1.WfRunId.encode(message.wfRunId, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListTaskRunsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.wfRunId = object_id_1.WfRunId.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.ListTaskRunsRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseListTaskRunsRequest();
        message.wfRunId = (object.wfRunId !== undefined && object.wfRunId !== null)
            ? object_id_1.WfRunId.fromPartial(object.wfRunId)
            : undefined;
        return message;
    },
};
function createBaseTaskRunList() {
    return { results: [] };
}
exports.TaskRunList = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.results) {
            task_run_1.TaskRun.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTaskRunList();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.results.push(task_run_1.TaskRun.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.TaskRunList.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseTaskRunList();
        message.results = ((_a = object.results) === null || _a === void 0 ? void 0 : _a.map((e) => task_run_1.TaskRun.fromPartial(e))) || [];
        return message;
    },
};
function createBaseMigrateWfSpecRequest() {
    return { oldWfSpec: undefined, migration: undefined };
}
exports.MigrateWfSpecRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.oldWfSpec !== undefined) {
            object_id_1.WfSpecId.encode(message.oldWfSpec, writer.uint32(10).fork()).ldelim();
        }
        if (message.migration !== undefined) {
            wf_spec_1.WfSpecVersionMigration.encode(message.migration, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMigrateWfSpecRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.oldWfSpec = object_id_1.WfSpecId.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.migration = wf_spec_1.WfSpecVersionMigration.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.MigrateWfSpecRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseMigrateWfSpecRequest();
        message.oldWfSpec = (object.oldWfSpec !== undefined && object.oldWfSpec !== null)
            ? object_id_1.WfSpecId.fromPartial(object.oldWfSpec)
            : undefined;
        message.migration = (object.migration !== undefined && object.migration !== null)
            ? wf_spec_1.WfSpecVersionMigration.fromPartial(object.migration)
            : undefined;
        return message;
    },
};
function createBaseGetLatestWfSpecRequest() {
    return { name: "", majorVersion: undefined };
}
exports.GetLatestWfSpecRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.majorVersion !== undefined) {
            writer.uint32(16).int32(message.majorVersion);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetLatestWfSpecRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.majorVersion = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.GetLatestWfSpecRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseGetLatestWfSpecRequest();
        message.name = (_a = object.name) !== null && _a !== void 0 ? _a : "";
        message.majorVersion = (_b = object.majorVersion) !== null && _b !== void 0 ? _b : undefined;
        return message;
    },
};
function createBaseServerVersionResponse() {
    return { majorVersion: 0, minorVersion: 0, patchVersion: 0, preReleaseIdentifier: undefined };
}
exports.ServerVersionResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.majorVersion !== 0) {
            writer.uint32(8).int32(message.majorVersion);
        }
        if (message.minorVersion !== 0) {
            writer.uint32(16).int32(message.minorVersion);
        }
        if (message.patchVersion !== 0) {
            writer.uint32(24).int32(message.patchVersion);
        }
        if (message.preReleaseIdentifier !== undefined) {
            writer.uint32(34).string(message.preReleaseIdentifier);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseServerVersionResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.majorVersion = reader.int32();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.minorVersion = reader.int32();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.patchVersion = reader.int32();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.preReleaseIdentifier = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.ServerVersionResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseServerVersionResponse();
        message.majorVersion = (_a = object.majorVersion) !== null && _a !== void 0 ? _a : 0;
        message.minorVersion = (_b = object.minorVersion) !== null && _b !== void 0 ? _b : 0;
        message.patchVersion = (_c = object.patchVersion) !== null && _c !== void 0 ? _c : 0;
        message.preReleaseIdentifier = (_d = object.preReleaseIdentifier) !== null && _d !== void 0 ? _d : undefined;
        return message;
    },
};
exports.LittleHorseDefinition = {
    name: "LittleHorse",
    fullName: "littlehorse.LittleHorse",
    methods: {
        /** Creates a TaskDef. */
        putTaskDef: {
            name: "PutTaskDef",
            requestType: exports.PutTaskDefRequest,
            requestStream: false,
            responseType: task_def_1.TaskDef,
            responseStream: false,
            options: {},
        },
        /** Gets a TaskDef. */
        getTaskDef: {
            name: "GetTaskDef",
            requestType: object_id_1.TaskDefId,
            requestStream: false,
            responseType: task_def_1.TaskDef,
            responseStream: false,
            options: {},
        },
        /** Gets the registered task worker group associated with a specific TaskDef. */
        getTaskWorkerGroup: {
            name: "GetTaskWorkerGroup",
            requestType: object_id_1.TaskDefId,
            requestStream: false,
            responseType: exports.TaskWorkerGroup,
            responseStream: false,
            options: {},
        },
        /** Creates an ExternalEventDef. */
        putExternalEventDef: {
            name: "PutExternalEventDef",
            requestType: exports.PutExternalEventDefRequest,
            requestStream: false,
            responseType: external_event_1.ExternalEventDef,
            responseStream: false,
            options: {},
        },
        /** Gets an ExternalEventDef. */
        getExternalEventDef: {
            name: "GetExternalEventDef",
            requestType: object_id_1.ExternalEventDefId,
            requestStream: false,
            responseType: external_event_1.ExternalEventDef,
            responseStream: false,
            options: {},
        },
        /** EXPERIMENTAL: Creates a WorkflowEventDef. */
        putWorkflowEventDef: {
            name: "PutWorkflowEventDef",
            requestType: exports.PutWorkflowEventDefRequest,
            requestStream: false,
            responseType: workflow_event_1.WorkflowEventDef,
            responseStream: false,
            options: {},
        },
        /** Creates a WfSpec. */
        putWfSpec: {
            name: "PutWfSpec",
            requestType: exports.PutWfSpecRequest,
            requestStream: false,
            responseType: wf_spec_1.WfSpec,
            responseStream: false,
            options: {},
        },
        /** Gets a WfSpec. */
        getWfSpec: {
            name: "GetWfSpec",
            requestType: object_id_1.WfSpecId,
            requestStream: false,
            responseType: wf_spec_1.WfSpec,
            responseStream: false,
            options: {},
        },
        /** Returns the latest WfSpec with a specified name (and optionally a specified Major Version). */
        getLatestWfSpec: {
            name: "GetLatestWfSpec",
            requestType: exports.GetLatestWfSpecRequest,
            requestStream: false,
            responseType: wf_spec_1.WfSpec,
            responseStream: false,
            options: {},
        },
        /**
         * EXPERIMENTAL: Migrates all WfRun's from one version of a WfSpec onto a newer version of the
         * same WfSpec. This is useful for long-running WfRun's (eg. a 60-day marketing campaign) where
         * you must update WfRun's that are in the RUNNING state rather than allowing them to run to
         * completion.
         *
         * As of 0.7.2, this feature is only partially implemented.
         */
        migrateWfSpec: {
            name: "MigrateWfSpec",
            requestType: exports.MigrateWfSpecRequest,
            requestStream: false,
            responseType: wf_spec_1.WfSpec,
            responseStream: false,
            options: {},
        },
        /** Creates a UserTaskDef. */
        putUserTaskDef: {
            name: "PutUserTaskDef",
            requestType: exports.PutUserTaskDefRequest,
            requestStream: false,
            responseType: user_tasks_1.UserTaskDef,
            responseStream: false,
            options: {},
        },
        /**
         * Gets a specific UserTaskDef.
         *
         * This RPC is highly useful for applications built around
         * User Tasks. For example, a UI that dynamically displays form fields based on the User Task
         * might first receive a UserTaskRun, then use that UserTaskRun to look up the UserTaskDef.
         * The frontend would inspect the UserTaskDef and display a form field on the browser page
         * for each field in the UserTaskDef.
         */
        getUserTaskDef: {
            name: "GetUserTaskDef",
            requestType: object_id_1.UserTaskDefId,
            requestStream: false,
            responseType: user_tasks_1.UserTaskDef,
            responseStream: false,
            options: {},
        },
        /** Returns the most recent UserTaskDef with a specific name. */
        getLatestUserTaskDef: {
            name: "GetLatestUserTaskDef",
            requestType: exports.GetLatestUserTaskDefRequest,
            requestStream: false,
            responseType: user_tasks_1.UserTaskDef,
            responseStream: false,
            options: {},
        },
        /** Runs a WfSpec to create a WfRun. */
        runWf: {
            name: "RunWf",
            requestType: exports.RunWfRequest,
            requestStream: false,
            responseType: wf_run_1.WfRun,
            responseStream: false,
            options: {},
        },
        /**
         * Gets a WfRun. Although useful for development and debugging, this RPC is not often
         * used by applications.
         */
        getWfRun: {
            name: "GetWfRun",
            requestType: object_id_1.WfRunId,
            requestStream: false,
            responseType: wf_run_1.WfRun,
            responseStream: false,
            options: {},
        },
        /**
         * Loads a specific UserTaskRun. It includes information about to whom the UserTask is
         * currently assigned, history of assignments and reassignments, and any context for that
         * UserTaskRun which is specific to the WfRun.
         */
        getUserTaskRun: {
            name: "GetUserTaskRun",
            requestType: object_id_1.UserTaskRunId,
            requestStream: false,
            responseType: user_tasks_1.UserTaskRun,
            responseStream: false,
            options: {},
        },
        /**
         * Change the ownership of a UserTaskRun to a new userId, userGroup, or both. The
         * action will be reflected in your next call to SearchUserTaskRun. This RPC is useful for
         * applications that are using User Tasks to build an internal task-list and wish to
         * administer the tasks.
         */
        assignUserTaskRun: {
            name: "AssignUserTaskRun",
            requestType: user_tasks_1.AssignUserTaskRunRequest,
            requestStream: false,
            responseType: empty_1.Empty,
            responseStream: false,
            options: {},
        },
        /**
         * Completes a UserTaskRun. Includes the results of the UserTaskRun, the UserTaskRun Id, and
         * the userId of the user who completes the UserTaskRun. Results in the UserTask NodeRun being
         * completed, and unblocks the associated ThreadRun in the WfRun.
         *
         * This RPC is highly useful for applications built around a WfSpec that uses USER_TASK nodes.
         */
        completeUserTaskRun: {
            name: "CompleteUserTaskRun",
            requestType: user_tasks_1.CompleteUserTaskRunRequest,
            requestStream: false,
            responseType: empty_1.Empty,
            responseStream: false,
            options: {},
        },
        /** Cancels a UserTaskRun. This will result in an EXCEPTION being propagated to the WfRun. */
        cancelUserTaskRun: {
            name: "CancelUserTaskRun",
            requestType: user_tasks_1.CancelUserTaskRunRequest,
            requestStream: false,
            responseType: empty_1.Empty,
            responseStream: false,
            options: {},
        },
        /**
         * Lists all UserTaskRun's for a specific WfRun. Can be useful when using a WfRun
         * to model an entity.
         */
        listUserTaskRuns: {
            name: "ListUserTaskRuns",
            requestType: exports.ListUserTaskRunRequest,
            requestStream: false,
            responseType: exports.UserTaskRunList,
            responseStream: false,
            options: {},
        },
        /** Gets a specific NodeRun. */
        getNodeRun: {
            name: "GetNodeRun",
            requestType: object_id_1.NodeRunId,
            requestStream: false,
            responseType: node_run_1.NodeRun,
            responseStream: false,
            options: {},
        },
        /** Lists all NodeRun's for a specific WfRun. */
        listNodeRuns: {
            name: "ListNodeRuns",
            requestType: exports.ListNodeRunsRequest,
            requestStream: false,
            responseType: exports.NodeRunList,
            responseStream: false,
            options: {},
        },
        /** Gets a specific TaskRun. */
        getTaskRun: {
            name: "GetTaskRun",
            requestType: object_id_1.TaskRunId,
            requestStream: false,
            responseType: task_run_1.TaskRun,
            responseStream: false,
            options: {},
        },
        /** Lists all TaskRun's for a specific WfRun. */
        listTaskRuns: {
            name: "ListTaskRuns",
            requestType: exports.ListTaskRunsRequest,
            requestStream: false,
            responseType: exports.TaskRunList,
            responseStream: false,
            options: {},
        },
        /**
         * Get the value of a specific Variable. When using a WfRun to model an entity, this
         * RPC is useful for retrieving information. It is equivalent to looking up the value of a
         * column for a specific row in a SQL table.
         */
        getVariable: {
            name: "GetVariable",
            requestType: object_id_1.VariableId,
            requestStream: false,
            responseType: variable_1.Variable,
            responseStream: false,
            options: {},
        },
        /** List all Variables from a WfRun. */
        listVariables: {
            name: "ListVariables",
            requestType: exports.ListVariablesRequest,
            requestStream: false,
            responseType: exports.VariableList,
            responseStream: false,
            options: {},
        },
        /** Post an ExternalEvent. This RPC is highly useful for */
        putExternalEvent: {
            name: "PutExternalEvent",
            requestType: exports.PutExternalEventRequest,
            requestStream: false,
            responseType: external_event_1.ExternalEvent,
            responseStream: false,
            options: {},
        },
        /** Get a specific ExternalEvent. */
        getExternalEvent: {
            name: "GetExternalEvent",
            requestType: object_id_1.ExternalEventId,
            requestStream: false,
            responseType: external_event_1.ExternalEvent,
            responseStream: false,
            options: {},
        },
        /**
         * Waits for a WorkflowEvent to be thrown by a given WfRun. Returns immediately if a matching
         * WorkflowEvent has already been thrown; throws a DEADLINE_EXCEEDED error if the WorkflowEvent
         * is not thrown before the deadline specified by the client.
         *
         * To specify the deadline, the client should use GRPC deadlines.
         */
        awaitWorkflowEvent: {
            name: "AwaitWorkflowEvent",
            requestType: exports.AwaitWorkflowEventRequest,
            requestStream: false,
            responseType: workflow_event_1.WorkflowEvent,
            responseStream: false,
            options: {},
        },
        /** List ExternalEvent's for a specific WfRun. */
        listExternalEvents: {
            name: "ListExternalEvents",
            requestType: exports.ListExternalEventsRequest,
            requestStream: false,
            responseType: exports.ExternalEventList,
            responseStream: false,
            options: {},
        },
        /**
         * Search for WfRun's. This RPC is highly useful for applications that store data
         * in LittleHorse and need to find a specific WfRun based on certain indexed fields.
         */
        searchWfRun: {
            name: "SearchWfRun",
            requestType: exports.SearchWfRunRequest,
            requestStream: false,
            responseType: exports.WfRunIdList,
            responseStream: false,
            options: {},
        },
        /**
         * Search for NodeRun's. This RPC is useful for monitoring and finding bugs in
         * your workflows or Task Workers.
         */
        searchNodeRun: {
            name: "SearchNodeRun",
            requestType: exports.SearchNodeRunRequest,
            requestStream: false,
            responseType: exports.NodeRunIdList,
            responseStream: false,
            options: {},
        },
        /** Search for TaskRun's. This RPC is useful for finding bugs in your Task Workers. */
        searchTaskRun: {
            name: "SearchTaskRun",
            requestType: exports.SearchTaskRunRequest,
            requestStream: false,
            responseType: exports.TaskRunIdList,
            responseStream: false,
            options: {},
        },
        /**
         * Search for UserTaskRun's. This RPC is highly useful for applications that connect
         * human end-users to LittleHorse: it enables you to find all tasks assigned to a specific
         * person or group of people.
         */
        searchUserTaskRun: {
            name: "SearchUserTaskRun",
            requestType: exports.SearchUserTaskRunRequest,
            requestStream: false,
            responseType: exports.UserTaskRunIdList,
            responseStream: false,
            options: {},
        },
        /**
         * Search for Variable's. This RPC is highly useful for applications that store data
         * in LittleHorse and need to find a specific WfRun based on certain indexed fields.
         */
        searchVariable: {
            name: "SearchVariable",
            requestType: exports.SearchVariableRequest,
            requestStream: false,
            responseType: exports.VariableIdList,
            responseStream: false,
            options: {},
        },
        /** Search for ExternalEvent's. */
        searchExternalEvent: {
            name: "SearchExternalEvent",
            requestType: exports.SearchExternalEventRequest,
            requestStream: false,
            responseType: exports.ExternalEventIdList,
            responseStream: false,
            options: {},
        },
        /** Search for TaskDef's. */
        searchTaskDef: {
            name: "SearchTaskDef",
            requestType: exports.SearchTaskDefRequest,
            requestStream: false,
            responseType: exports.TaskDefIdList,
            responseStream: false,
            options: {},
        },
        /** Search for UserTaskDef's. */
        searchUserTaskDef: {
            name: "SearchUserTaskDef",
            requestType: exports.SearchUserTaskDefRequest,
            requestStream: false,
            responseType: exports.UserTaskDefIdList,
            responseStream: false,
            options: {},
        },
        /** Search for WfSpec's. */
        searchWfSpec: {
            name: "SearchWfSpec",
            requestType: exports.SearchWfSpecRequest,
            requestStream: false,
            responseType: exports.WfSpecIdList,
            responseStream: false,
            options: {},
        },
        /** Search for ExternalEventDef's. */
        searchExternalEventDef: {
            name: "SearchExternalEventDef",
            requestType: exports.SearchExternalEventDefRequest,
            requestStream: false,
            responseType: exports.ExternalEventDefIdList,
            responseStream: false,
            options: {},
        },
        /** Search for all available TenantIds for current Principal */
        searchTenant: {
            name: "SearchTenant",
            requestType: exports.SearchTenantRequest,
            requestStream: false,
            responseType: exports.TenantIdList,
            responseStream: false,
            options: {},
        },
        /**  */
        searchPrincipal: {
            name: "SearchPrincipal",
            requestType: exports.SearchPrincipalRequest,
            requestStream: false,
            responseType: exports.PrincipalIdList,
            responseStream: false,
            options: {},
        },
        /**
         * Used by the Task Worker to:
         * 1. Tell the LH Server that the Task Worker has joined the Task Worker Group.
         * 2. Receive the assignemnt of LH Server's to poll from.
         * Generally, you won't use this request manually.
         */
        registerTaskWorker: {
            name: "RegisterTaskWorker",
            requestType: exports.RegisterTaskWorkerRequest,
            requestStream: false,
            responseType: exports.RegisterTaskWorkerResponse,
            responseStream: false,
            options: {},
        },
        /**
         * Used by Task Workers to listen for TaskRuns on the Task Queue. Generally, you won't
         * use this RPC manually.
         */
        pollTask: {
            name: "PollTask",
            requestType: exports.PollTaskRequest,
            requestStream: true,
            responseType: exports.PollTaskResponse,
            responseStream: true,
            options: {},
        },
        /**
         * Used by Task Workers to report the result of a TaskRun. Generally, you won't use
         * this rpc manually.
         */
        reportTask: {
            name: "ReportTask",
            requestType: exports.ReportTaskRun,
            requestStream: false,
            responseType: empty_1.Empty,
            responseStream: false,
            options: {},
        },
        /** Move a WfRun or a specific ThreadRun in that WfRun to the HALTED state. */
        stopWfRun: {
            name: "StopWfRun",
            requestType: exports.StopWfRunRequest,
            requestStream: false,
            responseType: empty_1.Empty,
            responseStream: false,
            options: {},
        },
        /** Resumes a WfRun or a specific ThreadRun of a WfRun. */
        resumeWfRun: {
            name: "ResumeWfRun",
            requestType: exports.ResumeWfRunRequest,
            requestStream: false,
            responseType: empty_1.Empty,
            responseStream: false,
            options: {},
        },
        /**
         * Rescues a failed ThreadRun (in the ERROR state only) by restarting it from
         * the point of failure. Useful if a bug in Task Worker implementation caused
         * a WfRun to fail and you did not have a FailureHandler for that NodeRun.
         *
         * The specified `ThreadRun` must be in a state where it's latest `NodeRun` is: <br/>
         * - In the `ERROR` state.<br/>
         * - Has no `FailureHandler` `ThreadRun`s <br/>
         * - The parent `ThreadRun`, or any parent of the parent, has not handled the `Failure`
         * yet.
         *
         * If that is not true, then the `ThreadRun` cannot be rescued and the request
         * will return `FAILED_PRECONDITION`.
         */
        rescueThreadRun: {
            name: "RescueThreadRun",
            requestType: exports.RescueThreadRunRequest,
            requestStream: false,
            responseType: wf_run_1.WfRun,
            responseStream: false,
            options: {},
        },
        /** Deletes a WfRun. The WfRun cannot be in the RUNNING state. */
        deleteWfRun: {
            name: "DeleteWfRun",
            requestType: exports.DeleteWfRunRequest,
            requestStream: false,
            responseType: empty_1.Empty,
            responseStream: false,
            options: {},
        },
        /** Deletes a TaskDef. */
        deleteTaskDef: {
            name: "DeleteTaskDef",
            requestType: exports.DeleteTaskDefRequest,
            requestStream: false,
            responseType: empty_1.Empty,
            responseStream: false,
            options: {},
        },
        /** Deletes a WfSpec. */
        deleteWfSpec: {
            name: "DeleteWfSpec",
            requestType: exports.DeleteWfSpecRequest,
            requestStream: false,
            responseType: empty_1.Empty,
            responseStream: false,
            options: {},
        },
        /** Deletes a UserTaskDef. */
        deleteUserTaskDef: {
            name: "DeleteUserTaskDef",
            requestType: exports.DeleteUserTaskDefRequest,
            requestStream: false,
            responseType: empty_1.Empty,
            responseStream: false,
            options: {},
        },
        /** Deletes an ExternalEventDef. */
        deleteExternalEventDef: {
            name: "DeleteExternalEventDef",
            requestType: exports.DeleteExternalEventDefRequest,
            requestStream: false,
            responseType: empty_1.Empty,
            responseStream: false,
            options: {},
        },
        /**
         * Deletes a `Principal`. Fails with `FAILED_PRECONDITION` if the specified `Principal`
         * is the last remaining `Principal` with admin permissions. Admin permissions are defined
         * as having the `global_acls` of `ALL_ACTIONS` over the `ACL_ALL_RESOURCES` scope.
         */
        deletePrincipal: {
            name: "DeletePrincipal",
            requestType: acls_1.DeletePrincipalRequest,
            requestStream: false,
            responseType: empty_1.Empty,
            responseStream: false,
            options: {},
        },
        /** Returns TaskDef Metrics for a specific TaskDef and a specific time window. */
        getTaskDefMetricsWindow: {
            name: "GetTaskDefMetricsWindow",
            requestType: exports.TaskDefMetricsQueryRequest,
            requestStream: false,
            responseType: exports.TaskDefMetrics,
            responseStream: false,
            options: {},
        },
        /** Returns WfSpec Metrics for a specific WfSpec and a specific time window. */
        getWfSpecMetricsWindow: {
            name: "GetWfSpecMetricsWindow",
            requestType: exports.WfSpecMetricsQueryRequest,
            requestStream: false,
            responseType: exports.WfSpecMetrics,
            responseStream: false,
            options: {},
        },
        /** Returns a list of TaskDef Metrics Windows. */
        listTaskDefMetrics: {
            name: "ListTaskDefMetrics",
            requestType: exports.ListTaskMetricsRequest,
            requestStream: false,
            responseType: exports.ListTaskMetricsResponse,
            responseStream: false,
            options: {},
        },
        /** Returns a list of WfSpec Metrics Windows. */
        listWfSpecMetrics: {
            name: "ListWfSpecMetrics",
            requestType: exports.ListWfMetricsRequest,
            requestStream: false,
            responseType: exports.ListWfMetricsResponse,
            responseStream: false,
            options: {},
        },
        /** EXPERIMENTAL: Creates another Tenant in the LH Server. */
        putTenant: {
            name: "PutTenant",
            requestType: acls_1.PutTenantRequest,
            requestStream: false,
            responseType: acls_1.Tenant,
            responseStream: false,
            options: {},
        },
        /** EXPERIMENTAL: Gets a Tenant from the LH Server. */
        getTenant: {
            name: "GetTenant",
            requestType: object_id_1.TenantId,
            requestStream: false,
            responseType: acls_1.Tenant,
            responseStream: false,
            options: {},
        },
        /** EXPERIMENTAL: Creates an Principal. */
        putPrincipal: {
            name: "PutPrincipal",
            requestType: acls_1.PutPrincipalRequest,
            requestStream: false,
            responseType: acls_1.Principal,
            responseStream: false,
            options: {},
        },
        /** Returns the Principal of the caller. */
        whoami: {
            name: "Whoami",
            requestType: empty_1.Empty,
            requestStream: false,
            responseType: acls_1.Principal,
            responseStream: false,
            options: {},
        },
        /** Gets the version of the LH Server. */
        getServerVersion: {
            name: "GetServerVersion",
            requestType: empty_1.Empty,
            requestStream: false,
            responseType: exports.ServerVersionResponse,
            responseStream: false,
            options: {},
        },
    },
};
function toTimestamp(dateStr) {
    const date = new globalThis.Date(dateStr);
    const seconds = Math.trunc(date.getTime() / 1000);
    const nanos = (date.getTime() % 1000) * 1000000;
    return { seconds, nanos };
}
function fromTimestamp(t) {
    let millis = (t.seconds || 0) * 1000;
    millis += (t.nanos || 0) / 1000000;
    return new globalThis.Date(millis).toISOString();
}
function longToNumber(long) {
    if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
        throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
//# sourceMappingURL=service.js.map