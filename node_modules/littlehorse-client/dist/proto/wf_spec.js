"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.178.0
//   protoc               v4.23.4
// source: wf_spec.proto
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeMigration = exports.ThreadSpecMigration_NodeMigrationsEntry = exports.ThreadSpecMigration = exports.WfSpecVersionMigration_ThreadSpecMigrationsEntry = exports.WfSpecVersionMigration = exports.SleepNode = exports.NopNode = exports.Edge = exports.EdgeCondition = exports.UserTaskNode = exports.ThrowEventNode = exports.Node = exports.FailureDef = exports.ExitNode = exports.EntrypointNode = exports.ExternalEventNode = exports.WaitForThreadsNode_ThreadsToWaitFor = exports.WaitForThreadsNode_ThreadToWaitFor = exports.WaitForThreadsNode = exports.FailureHandlerDef = exports.StartMultipleThreadsNode_VariablesEntry = exports.StartMultipleThreadsNode = exports.StartThreadNode_VariablesEntry = exports.StartThreadNode = exports.InterruptDef = exports.ThreadRetentionPolicy = exports.ThreadSpec_NodesEntry = exports.ThreadSpec = exports.ThreadVarDef = exports.JsonIndex = exports.WorkflowRetentionPolicy = exports.WfSpec_ParentWfSpecReference = exports.WfSpec_ThreadSpecsEntry = exports.WfSpec = exports.failureHandlerDef_LHFailureTypeToNumber = exports.failureHandlerDef_LHFailureTypeFromJSON = exports.FailureHandlerDef_LHFailureType = exports.wfRunVariableAccessLevelToNumber = exports.wfRunVariableAccessLevelFromJSON = exports.WfRunVariableAccessLevel = void 0;
/* eslint-disable */
const long_1 = __importDefault(require("long"));
const minimal_1 = __importDefault(require("protobufjs/minimal"));
const common_enums_1 = require("./common_enums");
const common_wfspec_1 = require("./common_wfspec");
const timestamp_1 = require("./google/protobuf/timestamp");
const object_id_1 = require("./object_id");
/** Determines the Access Level for a Variable in a ThreadSpec/WfSpec. */
var WfRunVariableAccessLevel;
(function (WfRunVariableAccessLevel) {
    /** PUBLIC_VAR - A `PUBLIC_VAR` can be accessed (read + mutated) by child `WfRun`'s. */
    WfRunVariableAccessLevel["PUBLIC_VAR"] = "PUBLIC_VAR";
    /** PRIVATE_VAR - A `PRIVATE_VAR` cannot be accessed by a child `WfRun`. */
    WfRunVariableAccessLevel["PRIVATE_VAR"] = "PRIVATE_VAR";
    /**
     * INHERITED_VAR - An `INHERITED_VAR` is inherited from the parent `WfRun`. Only valid in a `WfSpec` that
     * has a parent. Also can only be declared in the Entrypoint Thread.
     */
    WfRunVariableAccessLevel["INHERITED_VAR"] = "INHERITED_VAR";
    WfRunVariableAccessLevel["UNRECOGNIZED"] = "UNRECOGNIZED";
})(WfRunVariableAccessLevel || (exports.WfRunVariableAccessLevel = WfRunVariableAccessLevel = {}));
function wfRunVariableAccessLevelFromJSON(object) {
    switch (object) {
        case 0:
        case "PUBLIC_VAR":
            return WfRunVariableAccessLevel.PUBLIC_VAR;
        case 1:
        case "PRIVATE_VAR":
            return WfRunVariableAccessLevel.PRIVATE_VAR;
        case 2:
        case "INHERITED_VAR":
            return WfRunVariableAccessLevel.INHERITED_VAR;
        case -1:
        case "UNRECOGNIZED":
        default:
            return WfRunVariableAccessLevel.UNRECOGNIZED;
    }
}
exports.wfRunVariableAccessLevelFromJSON = wfRunVariableAccessLevelFromJSON;
function wfRunVariableAccessLevelToNumber(object) {
    switch (object) {
        case WfRunVariableAccessLevel.PUBLIC_VAR:
            return 0;
        case WfRunVariableAccessLevel.PRIVATE_VAR:
            return 1;
        case WfRunVariableAccessLevel.INHERITED_VAR:
            return 2;
        case WfRunVariableAccessLevel.UNRECOGNIZED:
        default:
            return -1;
    }
}
exports.wfRunVariableAccessLevelToNumber = wfRunVariableAccessLevelToNumber;
/** Specifies a type of Failure */
var FailureHandlerDef_LHFailureType;
(function (FailureHandlerDef_LHFailureType) {
    /** FAILURE_TYPE_ERROR - FAILURE_TYPE_ERROR specifies any technical `ERROR`. */
    FailureHandlerDef_LHFailureType["FAILURE_TYPE_ERROR"] = "FAILURE_TYPE_ERROR";
    /** FAILURE_TYPE_EXCEPTION - Specifies a user-defined, business-related `EXCEPTION`. */
    FailureHandlerDef_LHFailureType["FAILURE_TYPE_EXCEPTION"] = "FAILURE_TYPE_EXCEPTION";
    FailureHandlerDef_LHFailureType["UNRECOGNIZED"] = "UNRECOGNIZED";
})(FailureHandlerDef_LHFailureType || (exports.FailureHandlerDef_LHFailureType = FailureHandlerDef_LHFailureType = {}));
function failureHandlerDef_LHFailureTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "FAILURE_TYPE_ERROR":
            return FailureHandlerDef_LHFailureType.FAILURE_TYPE_ERROR;
        case 1:
        case "FAILURE_TYPE_EXCEPTION":
            return FailureHandlerDef_LHFailureType.FAILURE_TYPE_EXCEPTION;
        case -1:
        case "UNRECOGNIZED":
        default:
            return FailureHandlerDef_LHFailureType.UNRECOGNIZED;
    }
}
exports.failureHandlerDef_LHFailureTypeFromJSON = failureHandlerDef_LHFailureTypeFromJSON;
function failureHandlerDef_LHFailureTypeToNumber(object) {
    switch (object) {
        case FailureHandlerDef_LHFailureType.FAILURE_TYPE_ERROR:
            return 0;
        case FailureHandlerDef_LHFailureType.FAILURE_TYPE_EXCEPTION:
            return 1;
        case FailureHandlerDef_LHFailureType.UNRECOGNIZED:
        default:
            return -1;
    }
}
exports.failureHandlerDef_LHFailureTypeToNumber = failureHandlerDef_LHFailureTypeToNumber;
function createBaseWfSpec() {
    return {
        id: undefined,
        createdAt: undefined,
        frozenVariables: [],
        status: common_enums_1.MetadataStatus.ACTIVE,
        threadSpecs: {},
        entrypointThreadName: "",
        retentionPolicy: undefined,
        migration: undefined,
        parentWfSpec: undefined,
    };
}
exports.WfSpec = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.id !== undefined) {
            object_id_1.WfSpecId.encode(message.id, writer.uint32(10).fork()).ldelim();
        }
        if (message.createdAt !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.frozenVariables) {
            exports.ThreadVarDef.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.status !== common_enums_1.MetadataStatus.ACTIVE) {
            writer.uint32(32).int32((0, common_enums_1.metadataStatusToNumber)(message.status));
        }
        Object.entries(message.threadSpecs).forEach(([key, value]) => {
            exports.WfSpec_ThreadSpecsEntry.encode({ key: key, value }, writer.uint32(42).fork()).ldelim();
        });
        if (message.entrypointThreadName !== "") {
            writer.uint32(50).string(message.entrypointThreadName);
        }
        if (message.retentionPolicy !== undefined) {
            exports.WorkflowRetentionPolicy.encode(message.retentionPolicy, writer.uint32(58).fork()).ldelim();
        }
        if (message.migration !== undefined) {
            exports.WfSpecVersionMigration.encode(message.migration, writer.uint32(66).fork()).ldelim();
        }
        if (message.parentWfSpec !== undefined) {
            exports.WfSpec_ParentWfSpecReference.encode(message.parentWfSpec, writer.uint32(74).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWfSpec();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.id = object_id_1.WfSpecId.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.createdAt = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.frozenVariables.push(exports.ThreadVarDef.decode(reader, reader.uint32()));
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.status = (0, common_enums_1.metadataStatusFromJSON)(reader.int32());
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    const entry5 = exports.WfSpec_ThreadSpecsEntry.decode(reader, reader.uint32());
                    if (entry5.value !== undefined) {
                        message.threadSpecs[entry5.key] = entry5.value;
                    }
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.entrypointThreadName = reader.string();
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.retentionPolicy = exports.WorkflowRetentionPolicy.decode(reader, reader.uint32());
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.migration = exports.WfSpecVersionMigration.decode(reader, reader.uint32());
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.parentWfSpec = exports.WfSpec_ParentWfSpecReference.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.WfSpec.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseWfSpec();
        message.id = (object.id !== undefined && object.id !== null) ? object_id_1.WfSpecId.fromPartial(object.id) : undefined;
        message.createdAt = (_a = object.createdAt) !== null && _a !== void 0 ? _a : undefined;
        message.frozenVariables = ((_b = object.frozenVariables) === null || _b === void 0 ? void 0 : _b.map((e) => exports.ThreadVarDef.fromPartial(e))) || [];
        message.status = (_c = object.status) !== null && _c !== void 0 ? _c : common_enums_1.MetadataStatus.ACTIVE;
        message.threadSpecs = Object.entries((_d = object.threadSpecs) !== null && _d !== void 0 ? _d : {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = exports.ThreadSpec.fromPartial(value);
            }
            return acc;
        }, {});
        message.entrypointThreadName = (_e = object.entrypointThreadName) !== null && _e !== void 0 ? _e : "";
        message.retentionPolicy = (object.retentionPolicy !== undefined && object.retentionPolicy !== null)
            ? exports.WorkflowRetentionPolicy.fromPartial(object.retentionPolicy)
            : undefined;
        message.migration = (object.migration !== undefined && object.migration !== null)
            ? exports.WfSpecVersionMigration.fromPartial(object.migration)
            : undefined;
        message.parentWfSpec = (object.parentWfSpec !== undefined && object.parentWfSpec !== null)
            ? exports.WfSpec_ParentWfSpecReference.fromPartial(object.parentWfSpec)
            : undefined;
        return message;
    },
};
function createBaseWfSpec_ThreadSpecsEntry() {
    return { key: "", value: undefined };
}
exports.WfSpec_ThreadSpecsEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            exports.ThreadSpec.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWfSpec_ThreadSpecsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = exports.ThreadSpec.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.WfSpec_ThreadSpecsEntry.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseWfSpec_ThreadSpecsEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value = (object.value !== undefined && object.value !== null)
            ? exports.ThreadSpec.fromPartial(object.value)
            : undefined;
        return message;
    },
};
function createBaseWfSpec_ParentWfSpecReference() {
    return { wfSpecName: "", wfSpecMajorVersion: 0 };
}
exports.WfSpec_ParentWfSpecReference = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.wfSpecName !== "") {
            writer.uint32(10).string(message.wfSpecName);
        }
        if (message.wfSpecMajorVersion !== 0) {
            writer.uint32(16).int32(message.wfSpecMajorVersion);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWfSpec_ParentWfSpecReference();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.wfSpecName = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.wfSpecMajorVersion = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.WfSpec_ParentWfSpecReference.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseWfSpec_ParentWfSpecReference();
        message.wfSpecName = (_a = object.wfSpecName) !== null && _a !== void 0 ? _a : "";
        message.wfSpecMajorVersion = (_b = object.wfSpecMajorVersion) !== null && _b !== void 0 ? _b : 0;
        return message;
    },
};
function createBaseWorkflowRetentionPolicy() {
    return { secondsAfterWfTermination: undefined };
}
exports.WorkflowRetentionPolicy = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.secondsAfterWfTermination !== undefined) {
            writer.uint32(8).int64(message.secondsAfterWfTermination);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWorkflowRetentionPolicy();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.secondsAfterWfTermination = longToNumber(reader.int64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.WorkflowRetentionPolicy.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseWorkflowRetentionPolicy();
        message.secondsAfterWfTermination = (_a = object.secondsAfterWfTermination) !== null && _a !== void 0 ? _a : undefined;
        return message;
    },
};
function createBaseJsonIndex() {
    return { fieldPath: "", fieldType: common_enums_1.VariableType.JSON_OBJ };
}
exports.JsonIndex = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.fieldPath !== "") {
            writer.uint32(10).string(message.fieldPath);
        }
        if (message.fieldType !== common_enums_1.VariableType.JSON_OBJ) {
            writer.uint32(16).int32((0, common_enums_1.variableTypeToNumber)(message.fieldType));
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseJsonIndex();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.fieldPath = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.fieldType = (0, common_enums_1.variableTypeFromJSON)(reader.int32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.JsonIndex.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseJsonIndex();
        message.fieldPath = (_a = object.fieldPath) !== null && _a !== void 0 ? _a : "";
        message.fieldType = (_b = object.fieldType) !== null && _b !== void 0 ? _b : common_enums_1.VariableType.JSON_OBJ;
        return message;
    },
};
function createBaseThreadVarDef() {
    return {
        varDef: undefined,
        required: false,
        searchable: false,
        jsonIndexes: [],
        accessLevel: WfRunVariableAccessLevel.PUBLIC_VAR,
    };
}
exports.ThreadVarDef = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.varDef !== undefined) {
            common_wfspec_1.VariableDef.encode(message.varDef, writer.uint32(10).fork()).ldelim();
        }
        if (message.required !== false) {
            writer.uint32(16).bool(message.required);
        }
        if (message.searchable !== false) {
            writer.uint32(24).bool(message.searchable);
        }
        for (const v of message.jsonIndexes) {
            exports.JsonIndex.encode(v, writer.uint32(34).fork()).ldelim();
        }
        if (message.accessLevel !== WfRunVariableAccessLevel.PUBLIC_VAR) {
            writer.uint32(40).int32(wfRunVariableAccessLevelToNumber(message.accessLevel));
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseThreadVarDef();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.varDef = common_wfspec_1.VariableDef.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.required = reader.bool();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.searchable = reader.bool();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.jsonIndexes.push(exports.JsonIndex.decode(reader, reader.uint32()));
                    continue;
                case 5:
                    if (tag !== 40) {
                        break;
                    }
                    message.accessLevel = wfRunVariableAccessLevelFromJSON(reader.int32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.ThreadVarDef.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseThreadVarDef();
        message.varDef = (object.varDef !== undefined && object.varDef !== null)
            ? common_wfspec_1.VariableDef.fromPartial(object.varDef)
            : undefined;
        message.required = (_a = object.required) !== null && _a !== void 0 ? _a : false;
        message.searchable = (_b = object.searchable) !== null && _b !== void 0 ? _b : false;
        message.jsonIndexes = ((_c = object.jsonIndexes) === null || _c === void 0 ? void 0 : _c.map((e) => exports.JsonIndex.fromPartial(e))) || [];
        message.accessLevel = (_d = object.accessLevel) !== null && _d !== void 0 ? _d : WfRunVariableAccessLevel.PUBLIC_VAR;
        return message;
    },
};
function createBaseThreadSpec() {
    return { nodes: {}, variableDefs: [], interruptDefs: [], retentionPolicy: undefined };
}
exports.ThreadSpec = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        Object.entries(message.nodes).forEach(([key, value]) => {
            exports.ThreadSpec_NodesEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();
        });
        for (const v of message.variableDefs) {
            exports.ThreadVarDef.encode(v, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.interruptDefs) {
            exports.InterruptDef.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.retentionPolicy !== undefined) {
            exports.ThreadRetentionPolicy.encode(message.retentionPolicy, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseThreadSpec();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    const entry1 = exports.ThreadSpec_NodesEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.nodes[entry1.key] = entry1.value;
                    }
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.variableDefs.push(exports.ThreadVarDef.decode(reader, reader.uint32()));
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.interruptDefs.push(exports.InterruptDef.decode(reader, reader.uint32()));
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.retentionPolicy = exports.ThreadRetentionPolicy.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.ThreadSpec.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseThreadSpec();
        message.nodes = Object.entries((_a = object.nodes) !== null && _a !== void 0 ? _a : {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = exports.Node.fromPartial(value);
            }
            return acc;
        }, {});
        message.variableDefs = ((_b = object.variableDefs) === null || _b === void 0 ? void 0 : _b.map((e) => exports.ThreadVarDef.fromPartial(e))) || [];
        message.interruptDefs = ((_c = object.interruptDefs) === null || _c === void 0 ? void 0 : _c.map((e) => exports.InterruptDef.fromPartial(e))) || [];
        message.retentionPolicy = (object.retentionPolicy !== undefined && object.retentionPolicy !== null)
            ? exports.ThreadRetentionPolicy.fromPartial(object.retentionPolicy)
            : undefined;
        return message;
    },
};
function createBaseThreadSpec_NodesEntry() {
    return { key: "", value: undefined };
}
exports.ThreadSpec_NodesEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            exports.Node.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseThreadSpec_NodesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = exports.Node.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.ThreadSpec_NodesEntry.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseThreadSpec_NodesEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value = (object.value !== undefined && object.value !== null) ? exports.Node.fromPartial(object.value) : undefined;
        return message;
    },
};
function createBaseThreadRetentionPolicy() {
    return { secondsAfterThreadTermination: undefined };
}
exports.ThreadRetentionPolicy = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.secondsAfterThreadTermination !== undefined) {
            writer.uint32(8).int64(message.secondsAfterThreadTermination);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseThreadRetentionPolicy();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.secondsAfterThreadTermination = longToNumber(reader.int64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.ThreadRetentionPolicy.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseThreadRetentionPolicy();
        message.secondsAfterThreadTermination = (_a = object.secondsAfterThreadTermination) !== null && _a !== void 0 ? _a : undefined;
        return message;
    },
};
function createBaseInterruptDef() {
    return { externalEventDefId: undefined, handlerSpecName: "" };
}
exports.InterruptDef = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.externalEventDefId !== undefined) {
            object_id_1.ExternalEventDefId.encode(message.externalEventDefId, writer.uint32(10).fork()).ldelim();
        }
        if (message.handlerSpecName !== "") {
            writer.uint32(18).string(message.handlerSpecName);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInterruptDef();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.externalEventDefId = object_id_1.ExternalEventDefId.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.handlerSpecName = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.InterruptDef.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseInterruptDef();
        message.externalEventDefId = (object.externalEventDefId !== undefined && object.externalEventDefId !== null)
            ? object_id_1.ExternalEventDefId.fromPartial(object.externalEventDefId)
            : undefined;
        message.handlerSpecName = (_a = object.handlerSpecName) !== null && _a !== void 0 ? _a : "";
        return message;
    },
};
function createBaseStartThreadNode() {
    return { threadSpecName: "", variables: {} };
}
exports.StartThreadNode = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.threadSpecName !== "") {
            writer.uint32(10).string(message.threadSpecName);
        }
        Object.entries(message.variables).forEach(([key, value]) => {
            exports.StartThreadNode_VariablesEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStartThreadNode();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.threadSpecName = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    const entry2 = exports.StartThreadNode_VariablesEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.variables[entry2.key] = entry2.value;
                    }
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.StartThreadNode.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseStartThreadNode();
        message.threadSpecName = (_a = object.threadSpecName) !== null && _a !== void 0 ? _a : "";
        message.variables = Object.entries((_b = object.variables) !== null && _b !== void 0 ? _b : {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = common_wfspec_1.VariableAssignment.fromPartial(value);
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseStartThreadNode_VariablesEntry() {
    return { key: "", value: undefined };
}
exports.StartThreadNode_VariablesEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            common_wfspec_1.VariableAssignment.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStartThreadNode_VariablesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = common_wfspec_1.VariableAssignment.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.StartThreadNode_VariablesEntry.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseStartThreadNode_VariablesEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value = (object.value !== undefined && object.value !== null)
            ? common_wfspec_1.VariableAssignment.fromPartial(object.value)
            : undefined;
        return message;
    },
};
function createBaseStartMultipleThreadsNode() {
    return { threadSpecName: "", variables: {}, iterable: undefined };
}
exports.StartMultipleThreadsNode = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.threadSpecName !== "") {
            writer.uint32(10).string(message.threadSpecName);
        }
        Object.entries(message.variables).forEach(([key, value]) => {
            exports.StartMultipleThreadsNode_VariablesEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        if (message.iterable !== undefined) {
            common_wfspec_1.VariableAssignment.encode(message.iterable, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStartMultipleThreadsNode();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.threadSpecName = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    const entry2 = exports.StartMultipleThreadsNode_VariablesEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.variables[entry2.key] = entry2.value;
                    }
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.iterable = common_wfspec_1.VariableAssignment.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.StartMultipleThreadsNode.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseStartMultipleThreadsNode();
        message.threadSpecName = (_a = object.threadSpecName) !== null && _a !== void 0 ? _a : "";
        message.variables = Object.entries((_b = object.variables) !== null && _b !== void 0 ? _b : {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = common_wfspec_1.VariableAssignment.fromPartial(value);
            }
            return acc;
        }, {});
        message.iterable = (object.iterable !== undefined && object.iterable !== null)
            ? common_wfspec_1.VariableAssignment.fromPartial(object.iterable)
            : undefined;
        return message;
    },
};
function createBaseStartMultipleThreadsNode_VariablesEntry() {
    return { key: "", value: undefined };
}
exports.StartMultipleThreadsNode_VariablesEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            common_wfspec_1.VariableAssignment.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStartMultipleThreadsNode_VariablesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = common_wfspec_1.VariableAssignment.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.StartMultipleThreadsNode_VariablesEntry.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseStartMultipleThreadsNode_VariablesEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value = (object.value !== undefined && object.value !== null)
            ? common_wfspec_1.VariableAssignment.fromPartial(object.value)
            : undefined;
        return message;
    },
};
function createBaseFailureHandlerDef() {
    return { handlerSpecName: "", specificFailure: undefined, anyFailureOfType: undefined };
}
exports.FailureHandlerDef = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.handlerSpecName !== "") {
            writer.uint32(18).string(message.handlerSpecName);
        }
        if (message.specificFailure !== undefined) {
            writer.uint32(10).string(message.specificFailure);
        }
        if (message.anyFailureOfType !== undefined) {
            writer.uint32(24).int32(failureHandlerDef_LHFailureTypeToNumber(message.anyFailureOfType));
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFailureHandlerDef();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.handlerSpecName = reader.string();
                    continue;
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.specificFailure = reader.string();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.anyFailureOfType = failureHandlerDef_LHFailureTypeFromJSON(reader.int32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.FailureHandlerDef.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseFailureHandlerDef();
        message.handlerSpecName = (_a = object.handlerSpecName) !== null && _a !== void 0 ? _a : "";
        message.specificFailure = (_b = object.specificFailure) !== null && _b !== void 0 ? _b : undefined;
        message.anyFailureOfType = (_c = object.anyFailureOfType) !== null && _c !== void 0 ? _c : undefined;
        return message;
    },
};
function createBaseWaitForThreadsNode() {
    return { threads: undefined, threadList: undefined, perThreadFailureHandlers: [] };
}
exports.WaitForThreadsNode = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.threads !== undefined) {
            exports.WaitForThreadsNode_ThreadsToWaitFor.encode(message.threads, writer.uint32(10).fork()).ldelim();
        }
        if (message.threadList !== undefined) {
            common_wfspec_1.VariableAssignment.encode(message.threadList, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.perThreadFailureHandlers) {
            exports.FailureHandlerDef.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWaitForThreadsNode();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.threads = exports.WaitForThreadsNode_ThreadsToWaitFor.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.threadList = common_wfspec_1.VariableAssignment.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.perThreadFailureHandlers.push(exports.FailureHandlerDef.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.WaitForThreadsNode.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseWaitForThreadsNode();
        message.threads = (object.threads !== undefined && object.threads !== null)
            ? exports.WaitForThreadsNode_ThreadsToWaitFor.fromPartial(object.threads)
            : undefined;
        message.threadList = (object.threadList !== undefined && object.threadList !== null)
            ? common_wfspec_1.VariableAssignment.fromPartial(object.threadList)
            : undefined;
        message.perThreadFailureHandlers = ((_a = object.perThreadFailureHandlers) === null || _a === void 0 ? void 0 : _a.map((e) => exports.FailureHandlerDef.fromPartial(e))) ||
            [];
        return message;
    },
};
function createBaseWaitForThreadsNode_ThreadToWaitFor() {
    return { threadRunNumber: undefined };
}
exports.WaitForThreadsNode_ThreadToWaitFor = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.threadRunNumber !== undefined) {
            common_wfspec_1.VariableAssignment.encode(message.threadRunNumber, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWaitForThreadsNode_ThreadToWaitFor();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.threadRunNumber = common_wfspec_1.VariableAssignment.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.WaitForThreadsNode_ThreadToWaitFor.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseWaitForThreadsNode_ThreadToWaitFor();
        message.threadRunNumber = (object.threadRunNumber !== undefined && object.threadRunNumber !== null)
            ? common_wfspec_1.VariableAssignment.fromPartial(object.threadRunNumber)
            : undefined;
        return message;
    },
};
function createBaseWaitForThreadsNode_ThreadsToWaitFor() {
    return { threads: [] };
}
exports.WaitForThreadsNode_ThreadsToWaitFor = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.threads) {
            exports.WaitForThreadsNode_ThreadToWaitFor.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWaitForThreadsNode_ThreadsToWaitFor();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.threads.push(exports.WaitForThreadsNode_ThreadToWaitFor.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.WaitForThreadsNode_ThreadsToWaitFor.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseWaitForThreadsNode_ThreadsToWaitFor();
        message.threads = ((_a = object.threads) === null || _a === void 0 ? void 0 : _a.map((e) => exports.WaitForThreadsNode_ThreadToWaitFor.fromPartial(e))) || [];
        return message;
    },
};
function createBaseExternalEventNode() {
    return { externalEventDefId: undefined, timeoutSeconds: undefined };
}
exports.ExternalEventNode = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.externalEventDefId !== undefined) {
            object_id_1.ExternalEventDefId.encode(message.externalEventDefId, writer.uint32(10).fork()).ldelim();
        }
        if (message.timeoutSeconds !== undefined) {
            common_wfspec_1.VariableAssignment.encode(message.timeoutSeconds, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseExternalEventNode();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.externalEventDefId = object_id_1.ExternalEventDefId.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.timeoutSeconds = common_wfspec_1.VariableAssignment.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.ExternalEventNode.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseExternalEventNode();
        message.externalEventDefId = (object.externalEventDefId !== undefined && object.externalEventDefId !== null)
            ? object_id_1.ExternalEventDefId.fromPartial(object.externalEventDefId)
            : undefined;
        message.timeoutSeconds = (object.timeoutSeconds !== undefined && object.timeoutSeconds !== null)
            ? common_wfspec_1.VariableAssignment.fromPartial(object.timeoutSeconds)
            : undefined;
        return message;
    },
};
function createBaseEntrypointNode() {
    return {};
}
exports.EntrypointNode = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEntrypointNode();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.EntrypointNode.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(_) {
        const message = createBaseEntrypointNode();
        return message;
    },
};
function createBaseExitNode() {
    return { failureDef: undefined };
}
exports.ExitNode = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.failureDef !== undefined) {
            exports.FailureDef.encode(message.failureDef, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseExitNode();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.failureDef = exports.FailureDef.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.ExitNode.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseExitNode();
        message.failureDef = (object.failureDef !== undefined && object.failureDef !== null)
            ? exports.FailureDef.fromPartial(object.failureDef)
            : undefined;
        return message;
    },
};
function createBaseFailureDef() {
    return { failureName: "", message: "", content: undefined };
}
exports.FailureDef = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.failureName !== "") {
            writer.uint32(10).string(message.failureName);
        }
        if (message.message !== "") {
            writer.uint32(18).string(message.message);
        }
        if (message.content !== undefined) {
            common_wfspec_1.VariableAssignment.encode(message.content, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFailureDef();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.failureName = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.message = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.content = common_wfspec_1.VariableAssignment.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.FailureDef.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseFailureDef();
        message.failureName = (_a = object.failureName) !== null && _a !== void 0 ? _a : "";
        message.message = (_b = object.message) !== null && _b !== void 0 ? _b : "";
        message.content = (object.content !== undefined && object.content !== null)
            ? common_wfspec_1.VariableAssignment.fromPartial(object.content)
            : undefined;
        return message;
    },
};
function createBaseNode() {
    return {
        outgoingEdges: [],
        failureHandlers: [],
        entrypoint: undefined,
        exit: undefined,
        task: undefined,
        externalEvent: undefined,
        startThread: undefined,
        waitForThreads: undefined,
        nop: undefined,
        sleep: undefined,
        userTask: undefined,
        startMultipleThreads: undefined,
        throwEvent: undefined,
    };
}
exports.Node = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.outgoingEdges) {
            exports.Edge.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.failureHandlers) {
            exports.FailureHandlerDef.encode(v, writer.uint32(34).fork()).ldelim();
        }
        if (message.entrypoint !== undefined) {
            exports.EntrypointNode.encode(message.entrypoint, writer.uint32(42).fork()).ldelim();
        }
        if (message.exit !== undefined) {
            exports.ExitNode.encode(message.exit, writer.uint32(50).fork()).ldelim();
        }
        if (message.task !== undefined) {
            common_wfspec_1.TaskNode.encode(message.task, writer.uint32(58).fork()).ldelim();
        }
        if (message.externalEvent !== undefined) {
            exports.ExternalEventNode.encode(message.externalEvent, writer.uint32(66).fork()).ldelim();
        }
        if (message.startThread !== undefined) {
            exports.StartThreadNode.encode(message.startThread, writer.uint32(74).fork()).ldelim();
        }
        if (message.waitForThreads !== undefined) {
            exports.WaitForThreadsNode.encode(message.waitForThreads, writer.uint32(82).fork()).ldelim();
        }
        if (message.nop !== undefined) {
            exports.NopNode.encode(message.nop, writer.uint32(90).fork()).ldelim();
        }
        if (message.sleep !== undefined) {
            exports.SleepNode.encode(message.sleep, writer.uint32(98).fork()).ldelim();
        }
        if (message.userTask !== undefined) {
            exports.UserTaskNode.encode(message.userTask, writer.uint32(106).fork()).ldelim();
        }
        if (message.startMultipleThreads !== undefined) {
            exports.StartMultipleThreadsNode.encode(message.startMultipleThreads, writer.uint32(122).fork()).ldelim();
        }
        if (message.throwEvent !== undefined) {
            exports.ThrowEventNode.encode(message.throwEvent, writer.uint32(130).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseNode();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.outgoingEdges.push(exports.Edge.decode(reader, reader.uint32()));
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.failureHandlers.push(exports.FailureHandlerDef.decode(reader, reader.uint32()));
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.entrypoint = exports.EntrypointNode.decode(reader, reader.uint32());
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.exit = exports.ExitNode.decode(reader, reader.uint32());
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.task = common_wfspec_1.TaskNode.decode(reader, reader.uint32());
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.externalEvent = exports.ExternalEventNode.decode(reader, reader.uint32());
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.startThread = exports.StartThreadNode.decode(reader, reader.uint32());
                    continue;
                case 10:
                    if (tag !== 82) {
                        break;
                    }
                    message.waitForThreads = exports.WaitForThreadsNode.decode(reader, reader.uint32());
                    continue;
                case 11:
                    if (tag !== 90) {
                        break;
                    }
                    message.nop = exports.NopNode.decode(reader, reader.uint32());
                    continue;
                case 12:
                    if (tag !== 98) {
                        break;
                    }
                    message.sleep = exports.SleepNode.decode(reader, reader.uint32());
                    continue;
                case 13:
                    if (tag !== 106) {
                        break;
                    }
                    message.userTask = exports.UserTaskNode.decode(reader, reader.uint32());
                    continue;
                case 15:
                    if (tag !== 122) {
                        break;
                    }
                    message.startMultipleThreads = exports.StartMultipleThreadsNode.decode(reader, reader.uint32());
                    continue;
                case 16:
                    if (tag !== 130) {
                        break;
                    }
                    message.throwEvent = exports.ThrowEventNode.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.Node.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseNode();
        message.outgoingEdges = ((_a = object.outgoingEdges) === null || _a === void 0 ? void 0 : _a.map((e) => exports.Edge.fromPartial(e))) || [];
        message.failureHandlers = ((_b = object.failureHandlers) === null || _b === void 0 ? void 0 : _b.map((e) => exports.FailureHandlerDef.fromPartial(e))) || [];
        message.entrypoint = (object.entrypoint !== undefined && object.entrypoint !== null)
            ? exports.EntrypointNode.fromPartial(object.entrypoint)
            : undefined;
        message.exit = (object.exit !== undefined && object.exit !== null) ? exports.ExitNode.fromPartial(object.exit) : undefined;
        message.task = (object.task !== undefined && object.task !== null) ? common_wfspec_1.TaskNode.fromPartial(object.task) : undefined;
        message.externalEvent = (object.externalEvent !== undefined && object.externalEvent !== null)
            ? exports.ExternalEventNode.fromPartial(object.externalEvent)
            : undefined;
        message.startThread = (object.startThread !== undefined && object.startThread !== null)
            ? exports.StartThreadNode.fromPartial(object.startThread)
            : undefined;
        message.waitForThreads = (object.waitForThreads !== undefined && object.waitForThreads !== null)
            ? exports.WaitForThreadsNode.fromPartial(object.waitForThreads)
            : undefined;
        message.nop = (object.nop !== undefined && object.nop !== null) ? exports.NopNode.fromPartial(object.nop) : undefined;
        message.sleep = (object.sleep !== undefined && object.sleep !== null)
            ? exports.SleepNode.fromPartial(object.sleep)
            : undefined;
        message.userTask = (object.userTask !== undefined && object.userTask !== null)
            ? exports.UserTaskNode.fromPartial(object.userTask)
            : undefined;
        message.startMultipleThreads = (object.startMultipleThreads !== undefined && object.startMultipleThreads !== null)
            ? exports.StartMultipleThreadsNode.fromPartial(object.startMultipleThreads)
            : undefined;
        message.throwEvent = (object.throwEvent !== undefined && object.throwEvent !== null)
            ? exports.ThrowEventNode.fromPartial(object.throwEvent)
            : undefined;
        return message;
    },
};
function createBaseThrowEventNode() {
    return { eventDefId: undefined, content: undefined };
}
exports.ThrowEventNode = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.eventDefId !== undefined) {
            object_id_1.WorkflowEventDefId.encode(message.eventDefId, writer.uint32(10).fork()).ldelim();
        }
        if (message.content !== undefined) {
            common_wfspec_1.VariableAssignment.encode(message.content, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseThrowEventNode();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.eventDefId = object_id_1.WorkflowEventDefId.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.content = common_wfspec_1.VariableAssignment.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.ThrowEventNode.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseThrowEventNode();
        message.eventDefId = (object.eventDefId !== undefined && object.eventDefId !== null)
            ? object_id_1.WorkflowEventDefId.fromPartial(object.eventDefId)
            : undefined;
        message.content = (object.content !== undefined && object.content !== null)
            ? common_wfspec_1.VariableAssignment.fromPartial(object.content)
            : undefined;
        return message;
    },
};
function createBaseUserTaskNode() {
    return {
        userTaskDefName: "",
        userGroup: undefined,
        userId: undefined,
        actions: [],
        userTaskDefVersion: undefined,
        notes: undefined,
        onCancellationExceptionName: undefined,
    };
}
exports.UserTaskNode = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.userTaskDefName !== "") {
            writer.uint32(10).string(message.userTaskDefName);
        }
        if (message.userGroup !== undefined) {
            common_wfspec_1.VariableAssignment.encode(message.userGroup, writer.uint32(18).fork()).ldelim();
        }
        if (message.userId !== undefined) {
            common_wfspec_1.VariableAssignment.encode(message.userId, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.actions) {
            common_wfspec_1.UTActionTrigger.encode(v, writer.uint32(34).fork()).ldelim();
        }
        if (message.userTaskDefVersion !== undefined) {
            writer.uint32(40).int32(message.userTaskDefVersion);
        }
        if (message.notes !== undefined) {
            common_wfspec_1.VariableAssignment.encode(message.notes, writer.uint32(50).fork()).ldelim();
        }
        if (message.onCancellationExceptionName !== undefined) {
            common_wfspec_1.VariableAssignment.encode(message.onCancellationExceptionName, writer.uint32(58).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserTaskNode();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.userTaskDefName = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.userGroup = common_wfspec_1.VariableAssignment.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.userId = common_wfspec_1.VariableAssignment.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.actions.push(common_wfspec_1.UTActionTrigger.decode(reader, reader.uint32()));
                    continue;
                case 5:
                    if (tag !== 40) {
                        break;
                    }
                    message.userTaskDefVersion = reader.int32();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.notes = common_wfspec_1.VariableAssignment.decode(reader, reader.uint32());
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.onCancellationExceptionName = common_wfspec_1.VariableAssignment.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.UserTaskNode.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseUserTaskNode();
        message.userTaskDefName = (_a = object.userTaskDefName) !== null && _a !== void 0 ? _a : "";
        message.userGroup = (object.userGroup !== undefined && object.userGroup !== null)
            ? common_wfspec_1.VariableAssignment.fromPartial(object.userGroup)
            : undefined;
        message.userId = (object.userId !== undefined && object.userId !== null)
            ? common_wfspec_1.VariableAssignment.fromPartial(object.userId)
            : undefined;
        message.actions = ((_b = object.actions) === null || _b === void 0 ? void 0 : _b.map((e) => common_wfspec_1.UTActionTrigger.fromPartial(e))) || [];
        message.userTaskDefVersion = (_c = object.userTaskDefVersion) !== null && _c !== void 0 ? _c : undefined;
        message.notes = (object.notes !== undefined && object.notes !== null)
            ? common_wfspec_1.VariableAssignment.fromPartial(object.notes)
            : undefined;
        message.onCancellationExceptionName =
            (object.onCancellationExceptionName !== undefined && object.onCancellationExceptionName !== null)
                ? common_wfspec_1.VariableAssignment.fromPartial(object.onCancellationExceptionName)
                : undefined;
        return message;
    },
};
function createBaseEdgeCondition() {
    return { comparator: common_wfspec_1.Comparator.LESS_THAN, left: undefined, right: undefined };
}
exports.EdgeCondition = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.comparator !== common_wfspec_1.Comparator.LESS_THAN) {
            writer.uint32(8).int32((0, common_wfspec_1.comparatorToNumber)(message.comparator));
        }
        if (message.left !== undefined) {
            common_wfspec_1.VariableAssignment.encode(message.left, writer.uint32(18).fork()).ldelim();
        }
        if (message.right !== undefined) {
            common_wfspec_1.VariableAssignment.encode(message.right, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEdgeCondition();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.comparator = (0, common_wfspec_1.comparatorFromJSON)(reader.int32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.left = common_wfspec_1.VariableAssignment.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.right = common_wfspec_1.VariableAssignment.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.EdgeCondition.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseEdgeCondition();
        message.comparator = (_a = object.comparator) !== null && _a !== void 0 ? _a : common_wfspec_1.Comparator.LESS_THAN;
        message.left = (object.left !== undefined && object.left !== null)
            ? common_wfspec_1.VariableAssignment.fromPartial(object.left)
            : undefined;
        message.right = (object.right !== undefined && object.right !== null)
            ? common_wfspec_1.VariableAssignment.fromPartial(object.right)
            : undefined;
        return message;
    },
};
function createBaseEdge() {
    return { sinkNodeName: "", condition: undefined, variableMutations: [] };
}
exports.Edge = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sinkNodeName !== "") {
            writer.uint32(10).string(message.sinkNodeName);
        }
        if (message.condition !== undefined) {
            exports.EdgeCondition.encode(message.condition, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.variableMutations) {
            common_wfspec_1.VariableMutation.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEdge();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.sinkNodeName = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.condition = exports.EdgeCondition.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.variableMutations.push(common_wfspec_1.VariableMutation.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.Edge.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseEdge();
        message.sinkNodeName = (_a = object.sinkNodeName) !== null && _a !== void 0 ? _a : "";
        message.condition = (object.condition !== undefined && object.condition !== null)
            ? exports.EdgeCondition.fromPartial(object.condition)
            : undefined;
        message.variableMutations = ((_b = object.variableMutations) === null || _b === void 0 ? void 0 : _b.map((e) => common_wfspec_1.VariableMutation.fromPartial(e))) || [];
        return message;
    },
};
function createBaseNopNode() {
    return {};
}
exports.NopNode = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseNopNode();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.NopNode.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(_) {
        const message = createBaseNopNode();
        return message;
    },
};
function createBaseSleepNode() {
    return { rawSeconds: undefined, timestamp: undefined, isoDate: undefined };
}
exports.SleepNode = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.rawSeconds !== undefined) {
            common_wfspec_1.VariableAssignment.encode(message.rawSeconds, writer.uint32(10).fork()).ldelim();
        }
        if (message.timestamp !== undefined) {
            common_wfspec_1.VariableAssignment.encode(message.timestamp, writer.uint32(18).fork()).ldelim();
        }
        if (message.isoDate !== undefined) {
            common_wfspec_1.VariableAssignment.encode(message.isoDate, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSleepNode();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.rawSeconds = common_wfspec_1.VariableAssignment.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.timestamp = common_wfspec_1.VariableAssignment.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.isoDate = common_wfspec_1.VariableAssignment.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.SleepNode.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseSleepNode();
        message.rawSeconds = (object.rawSeconds !== undefined && object.rawSeconds !== null)
            ? common_wfspec_1.VariableAssignment.fromPartial(object.rawSeconds)
            : undefined;
        message.timestamp = (object.timestamp !== undefined && object.timestamp !== null)
            ? common_wfspec_1.VariableAssignment.fromPartial(object.timestamp)
            : undefined;
        message.isoDate = (object.isoDate !== undefined && object.isoDate !== null)
            ? common_wfspec_1.VariableAssignment.fromPartial(object.isoDate)
            : undefined;
        return message;
    },
};
function createBaseWfSpecVersionMigration() {
    return { newMajorVersion: 0, newRevision: 0, threadSpecMigrations: {} };
}
exports.WfSpecVersionMigration = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.newMajorVersion !== 0) {
            writer.uint32(8).int32(message.newMajorVersion);
        }
        if (message.newRevision !== 0) {
            writer.uint32(16).int32(message.newRevision);
        }
        Object.entries(message.threadSpecMigrations).forEach(([key, value]) => {
            exports.WfSpecVersionMigration_ThreadSpecMigrationsEntry.encode({ key: key, value }, writer.uint32(26).fork())
                .ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWfSpecVersionMigration();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.newMajorVersion = reader.int32();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.newRevision = reader.int32();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    const entry3 = exports.WfSpecVersionMigration_ThreadSpecMigrationsEntry.decode(reader, reader.uint32());
                    if (entry3.value !== undefined) {
                        message.threadSpecMigrations[entry3.key] = entry3.value;
                    }
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.WfSpecVersionMigration.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseWfSpecVersionMigration();
        message.newMajorVersion = (_a = object.newMajorVersion) !== null && _a !== void 0 ? _a : 0;
        message.newRevision = (_b = object.newRevision) !== null && _b !== void 0 ? _b : 0;
        message.threadSpecMigrations = Object.entries((_c = object.threadSpecMigrations) !== null && _c !== void 0 ? _c : {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = exports.ThreadSpecMigration.fromPartial(value);
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseWfSpecVersionMigration_ThreadSpecMigrationsEntry() {
    return { key: "", value: undefined };
}
exports.WfSpecVersionMigration_ThreadSpecMigrationsEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            exports.ThreadSpecMigration.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWfSpecVersionMigration_ThreadSpecMigrationsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = exports.ThreadSpecMigration.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.WfSpecVersionMigration_ThreadSpecMigrationsEntry.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseWfSpecVersionMigration_ThreadSpecMigrationsEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value = (object.value !== undefined && object.value !== null)
            ? exports.ThreadSpecMigration.fromPartial(object.value)
            : undefined;
        return message;
    },
};
function createBaseThreadSpecMigration() {
    return { newThreadSpecName: "", nodeMigrations: {} };
}
exports.ThreadSpecMigration = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.newThreadSpecName !== "") {
            writer.uint32(10).string(message.newThreadSpecName);
        }
        Object.entries(message.nodeMigrations).forEach(([key, value]) => {
            exports.ThreadSpecMigration_NodeMigrationsEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseThreadSpecMigration();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.newThreadSpecName = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    const entry2 = exports.ThreadSpecMigration_NodeMigrationsEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.nodeMigrations[entry2.key] = entry2.value;
                    }
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.ThreadSpecMigration.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseThreadSpecMigration();
        message.newThreadSpecName = (_a = object.newThreadSpecName) !== null && _a !== void 0 ? _a : "";
        message.nodeMigrations = Object.entries((_b = object.nodeMigrations) !== null && _b !== void 0 ? _b : {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = exports.NodeMigration.fromPartial(value);
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseThreadSpecMigration_NodeMigrationsEntry() {
    return { key: "", value: undefined };
}
exports.ThreadSpecMigration_NodeMigrationsEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            exports.NodeMigration.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseThreadSpecMigration_NodeMigrationsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = exports.NodeMigration.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.ThreadSpecMigration_NodeMigrationsEntry.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseThreadSpecMigration_NodeMigrationsEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value = (object.value !== undefined && object.value !== null)
            ? exports.NodeMigration.fromPartial(object.value)
            : undefined;
        return message;
    },
};
function createBaseNodeMigration() {
    return { newNodeName: "" };
}
exports.NodeMigration = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.newNodeName !== "") {
            writer.uint32(10).string(message.newNodeName);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseNodeMigration();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.newNodeName = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.NodeMigration.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseNodeMigration();
        message.newNodeName = (_a = object.newNodeName) !== null && _a !== void 0 ? _a : "";
        return message;
    },
};
function toTimestamp(dateStr) {
    const date = new globalThis.Date(dateStr);
    const seconds = Math.trunc(date.getTime() / 1000);
    const nanos = (date.getTime() % 1000) * 1000000;
    return { seconds, nanos };
}
function fromTimestamp(t) {
    let millis = (t.seconds || 0) * 1000;
    millis += (t.nanos || 0) / 1000000;
    return new globalThis.Date(millis).toISOString();
}
function longToNumber(long) {
    if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
        throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
//# sourceMappingURL=wf_spec.js.map