"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.178.0
//   protoc               v4.23.4
// source: node_run.proto
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Failure = exports.SleepNodeRun = exports.ExternalEventRun = exports.WaitForThreadsRun_WaitForThread = exports.WaitForThreadsRun = exports.StartMultipleThreadsRun = exports.StartThreadRun = exports.ExitRun = exports.EntrypointRun = exports.UserTaskNodeRun = exports.ThrowEventNodeRun = exports.TaskNodeRun = exports.NodeRun = exports.waitForThreadsRun_WaitingThreadStatusToNumber = exports.waitForThreadsRun_WaitingThreadStatusFromJSON = exports.WaitForThreadsRun_WaitingThreadStatus = void 0;
/* eslint-disable */
const minimal_1 = __importDefault(require("protobufjs/minimal"));
const common_enums_1 = require("./common_enums");
const timestamp_1 = require("./google/protobuf/timestamp");
const object_id_1 = require("./object_id");
const variable_1 = require("./variable");
/** The status of a single ThreadRun that we are waiting for. */
var WaitForThreadsRun_WaitingThreadStatus;
(function (WaitForThreadsRun_WaitingThreadStatus) {
    /** THREAD_IN_PROGRESS - The ThreadRun is in progress (i.e. not COMPLETED nor EXCEPTION nor ERROR) */
    WaitForThreadsRun_WaitingThreadStatus["THREAD_IN_PROGRESS"] = "THREAD_IN_PROGRESS";
    /**
     * THREAD_HANDLING_FAILURE - The ThreadRun failed with some failure, and the FailureHandler is running
     * for that Failure.
     */
    WaitForThreadsRun_WaitingThreadStatus["THREAD_HANDLING_FAILURE"] = "THREAD_HANDLING_FAILURE";
    /**
     * THREAD_COMPLETED_OR_FAILURE_HANDLED - We can mark this ThreadRun as "already waited for", meaning that either:
     * 1. It completed successfully, OR
     * 2. It failed, and the Failure Handler successfully completed
     */
    WaitForThreadsRun_WaitingThreadStatus["THREAD_COMPLETED_OR_FAILURE_HANDLED"] = "THREAD_COMPLETED_OR_FAILURE_HANDLED";
    /**
     * THREAD_UNSUCCESSFUL - The ThreadRun did not complete successfully, and there wasn't a successful
     * run of a Failure Handler for the Failure that was thrown.
     */
    WaitForThreadsRun_WaitingThreadStatus["THREAD_UNSUCCESSFUL"] = "THREAD_UNSUCCESSFUL";
    WaitForThreadsRun_WaitingThreadStatus["UNRECOGNIZED"] = "UNRECOGNIZED";
})(WaitForThreadsRun_WaitingThreadStatus || (exports.WaitForThreadsRun_WaitingThreadStatus = WaitForThreadsRun_WaitingThreadStatus = {}));
function waitForThreadsRun_WaitingThreadStatusFromJSON(object) {
    switch (object) {
        case 0:
        case "THREAD_IN_PROGRESS":
            return WaitForThreadsRun_WaitingThreadStatus.THREAD_IN_PROGRESS;
        case 1:
        case "THREAD_HANDLING_FAILURE":
            return WaitForThreadsRun_WaitingThreadStatus.THREAD_HANDLING_FAILURE;
        case 2:
        case "THREAD_COMPLETED_OR_FAILURE_HANDLED":
            return WaitForThreadsRun_WaitingThreadStatus.THREAD_COMPLETED_OR_FAILURE_HANDLED;
        case 3:
        case "THREAD_UNSUCCESSFUL":
            return WaitForThreadsRun_WaitingThreadStatus.THREAD_UNSUCCESSFUL;
        case -1:
        case "UNRECOGNIZED":
        default:
            return WaitForThreadsRun_WaitingThreadStatus.UNRECOGNIZED;
    }
}
exports.waitForThreadsRun_WaitingThreadStatusFromJSON = waitForThreadsRun_WaitingThreadStatusFromJSON;
function waitForThreadsRun_WaitingThreadStatusToNumber(object) {
    switch (object) {
        case WaitForThreadsRun_WaitingThreadStatus.THREAD_IN_PROGRESS:
            return 0;
        case WaitForThreadsRun_WaitingThreadStatus.THREAD_HANDLING_FAILURE:
            return 1;
        case WaitForThreadsRun_WaitingThreadStatus.THREAD_COMPLETED_OR_FAILURE_HANDLED:
            return 2;
        case WaitForThreadsRun_WaitingThreadStatus.THREAD_UNSUCCESSFUL:
            return 3;
        case WaitForThreadsRun_WaitingThreadStatus.UNRECOGNIZED:
        default:
            return -1;
    }
}
exports.waitForThreadsRun_WaitingThreadStatusToNumber = waitForThreadsRun_WaitingThreadStatusToNumber;
function createBaseNodeRun() {
    return {
        id: undefined,
        wfSpecId: undefined,
        failureHandlerIds: [],
        status: common_enums_1.LHStatus.STARTING,
        arrivalTime: undefined,
        endTime: undefined,
        threadSpecName: "",
        nodeName: "",
        errorMessage: undefined,
        failures: [],
        task: undefined,
        externalEvent: undefined,
        entrypoint: undefined,
        exit: undefined,
        startThread: undefined,
        waitThreads: undefined,
        sleep: undefined,
        userTask: undefined,
        startMultipleThreads: undefined,
        throwEvent: undefined,
    };
}
exports.NodeRun = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.id !== undefined) {
            object_id_1.NodeRunId.encode(message.id, writer.uint32(10).fork()).ldelim();
        }
        if (message.wfSpecId !== undefined) {
            object_id_1.WfSpecId.encode(message.wfSpecId, writer.uint32(34).fork()).ldelim();
        }
        writer.uint32(42).fork();
        for (const v of message.failureHandlerIds) {
            writer.int32(v);
        }
        writer.ldelim();
        if (message.status !== common_enums_1.LHStatus.STARTING) {
            writer.uint32(48).int32((0, common_enums_1.lHStatusToNumber)(message.status));
        }
        if (message.arrivalTime !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.arrivalTime), writer.uint32(58).fork()).ldelim();
        }
        if (message.endTime !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.endTime), writer.uint32(66).fork()).ldelim();
        }
        if (message.threadSpecName !== "") {
            writer.uint32(74).string(message.threadSpecName);
        }
        if (message.nodeName !== "") {
            writer.uint32(82).string(message.nodeName);
        }
        if (message.errorMessage !== undefined) {
            writer.uint32(90).string(message.errorMessage);
        }
        for (const v of message.failures) {
            exports.Failure.encode(v, writer.uint32(98).fork()).ldelim();
        }
        if (message.task !== undefined) {
            exports.TaskNodeRun.encode(message.task, writer.uint32(106).fork()).ldelim();
        }
        if (message.externalEvent !== undefined) {
            exports.ExternalEventRun.encode(message.externalEvent, writer.uint32(114).fork()).ldelim();
        }
        if (message.entrypoint !== undefined) {
            exports.EntrypointRun.encode(message.entrypoint, writer.uint32(122).fork()).ldelim();
        }
        if (message.exit !== undefined) {
            exports.ExitRun.encode(message.exit, writer.uint32(130).fork()).ldelim();
        }
        if (message.startThread !== undefined) {
            exports.StartThreadRun.encode(message.startThread, writer.uint32(138).fork()).ldelim();
        }
        if (message.waitThreads !== undefined) {
            exports.WaitForThreadsRun.encode(message.waitThreads, writer.uint32(146).fork()).ldelim();
        }
        if (message.sleep !== undefined) {
            exports.SleepNodeRun.encode(message.sleep, writer.uint32(154).fork()).ldelim();
        }
        if (message.userTask !== undefined) {
            exports.UserTaskNodeRun.encode(message.userTask, writer.uint32(162).fork()).ldelim();
        }
        if (message.startMultipleThreads !== undefined) {
            exports.StartMultipleThreadsRun.encode(message.startMultipleThreads, writer.uint32(170).fork()).ldelim();
        }
        if (message.throwEvent !== undefined) {
            exports.ThrowEventNodeRun.encode(message.throwEvent, writer.uint32(178).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseNodeRun();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.id = object_id_1.NodeRunId.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.wfSpecId = object_id_1.WfSpecId.decode(reader, reader.uint32());
                    continue;
                case 5:
                    if (tag === 40) {
                        message.failureHandlerIds.push(reader.int32());
                        continue;
                    }
                    if (tag === 42) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.failureHandlerIds.push(reader.int32());
                        }
                        continue;
                    }
                    break;
                case 6:
                    if (tag !== 48) {
                        break;
                    }
                    message.status = (0, common_enums_1.lHStatusFromJSON)(reader.int32());
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.arrivalTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.endTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.threadSpecName = reader.string();
                    continue;
                case 10:
                    if (tag !== 82) {
                        break;
                    }
                    message.nodeName = reader.string();
                    continue;
                case 11:
                    if (tag !== 90) {
                        break;
                    }
                    message.errorMessage = reader.string();
                    continue;
                case 12:
                    if (tag !== 98) {
                        break;
                    }
                    message.failures.push(exports.Failure.decode(reader, reader.uint32()));
                    continue;
                case 13:
                    if (tag !== 106) {
                        break;
                    }
                    message.task = exports.TaskNodeRun.decode(reader, reader.uint32());
                    continue;
                case 14:
                    if (tag !== 114) {
                        break;
                    }
                    message.externalEvent = exports.ExternalEventRun.decode(reader, reader.uint32());
                    continue;
                case 15:
                    if (tag !== 122) {
                        break;
                    }
                    message.entrypoint = exports.EntrypointRun.decode(reader, reader.uint32());
                    continue;
                case 16:
                    if (tag !== 130) {
                        break;
                    }
                    message.exit = exports.ExitRun.decode(reader, reader.uint32());
                    continue;
                case 17:
                    if (tag !== 138) {
                        break;
                    }
                    message.startThread = exports.StartThreadRun.decode(reader, reader.uint32());
                    continue;
                case 18:
                    if (tag !== 146) {
                        break;
                    }
                    message.waitThreads = exports.WaitForThreadsRun.decode(reader, reader.uint32());
                    continue;
                case 19:
                    if (tag !== 154) {
                        break;
                    }
                    message.sleep = exports.SleepNodeRun.decode(reader, reader.uint32());
                    continue;
                case 20:
                    if (tag !== 162) {
                        break;
                    }
                    message.userTask = exports.UserTaskNodeRun.decode(reader, reader.uint32());
                    continue;
                case 21:
                    if (tag !== 170) {
                        break;
                    }
                    message.startMultipleThreads = exports.StartMultipleThreadsRun.decode(reader, reader.uint32());
                    continue;
                case 22:
                    if (tag !== 178) {
                        break;
                    }
                    message.throwEvent = exports.ThrowEventNodeRun.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.NodeRun.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const message = createBaseNodeRun();
        message.id = (object.id !== undefined && object.id !== null) ? object_id_1.NodeRunId.fromPartial(object.id) : undefined;
        message.wfSpecId = (object.wfSpecId !== undefined && object.wfSpecId !== null)
            ? object_id_1.WfSpecId.fromPartial(object.wfSpecId)
            : undefined;
        message.failureHandlerIds = ((_a = object.failureHandlerIds) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];
        message.status = (_b = object.status) !== null && _b !== void 0 ? _b : common_enums_1.LHStatus.STARTING;
        message.arrivalTime = (_c = object.arrivalTime) !== null && _c !== void 0 ? _c : undefined;
        message.endTime = (_d = object.endTime) !== null && _d !== void 0 ? _d : undefined;
        message.threadSpecName = (_e = object.threadSpecName) !== null && _e !== void 0 ? _e : "";
        message.nodeName = (_f = object.nodeName) !== null && _f !== void 0 ? _f : "";
        message.errorMessage = (_g = object.errorMessage) !== null && _g !== void 0 ? _g : undefined;
        message.failures = ((_h = object.failures) === null || _h === void 0 ? void 0 : _h.map((e) => exports.Failure.fromPartial(e))) || [];
        message.task = (object.task !== undefined && object.task !== null)
            ? exports.TaskNodeRun.fromPartial(object.task)
            : undefined;
        message.externalEvent = (object.externalEvent !== undefined && object.externalEvent !== null)
            ? exports.ExternalEventRun.fromPartial(object.externalEvent)
            : undefined;
        message.entrypoint = (object.entrypoint !== undefined && object.entrypoint !== null)
            ? exports.EntrypointRun.fromPartial(object.entrypoint)
            : undefined;
        message.exit = (object.exit !== undefined && object.exit !== null) ? exports.ExitRun.fromPartial(object.exit) : undefined;
        message.startThread = (object.startThread !== undefined && object.startThread !== null)
            ? exports.StartThreadRun.fromPartial(object.startThread)
            : undefined;
        message.waitThreads = (object.waitThreads !== undefined && object.waitThreads !== null)
            ? exports.WaitForThreadsRun.fromPartial(object.waitThreads)
            : undefined;
        message.sleep = (object.sleep !== undefined && object.sleep !== null)
            ? exports.SleepNodeRun.fromPartial(object.sleep)
            : undefined;
        message.userTask = (object.userTask !== undefined && object.userTask !== null)
            ? exports.UserTaskNodeRun.fromPartial(object.userTask)
            : undefined;
        message.startMultipleThreads = (object.startMultipleThreads !== undefined && object.startMultipleThreads !== null)
            ? exports.StartMultipleThreadsRun.fromPartial(object.startMultipleThreads)
            : undefined;
        message.throwEvent = (object.throwEvent !== undefined && object.throwEvent !== null)
            ? exports.ThrowEventNodeRun.fromPartial(object.throwEvent)
            : undefined;
        return message;
    },
};
function createBaseTaskNodeRun() {
    return { taskRunId: undefined };
}
exports.TaskNodeRun = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.taskRunId !== undefined) {
            object_id_1.TaskRunId.encode(message.taskRunId, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTaskNodeRun();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.taskRunId = object_id_1.TaskRunId.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.TaskNodeRun.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseTaskNodeRun();
        message.taskRunId = (object.taskRunId !== undefined && object.taskRunId !== null)
            ? object_id_1.TaskRunId.fromPartial(object.taskRunId)
            : undefined;
        return message;
    },
};
function createBaseThrowEventNodeRun() {
    return { workflowEventId: undefined };
}
exports.ThrowEventNodeRun = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.workflowEventId !== undefined) {
            object_id_1.WorkflowEventId.encode(message.workflowEventId, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseThrowEventNodeRun();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.workflowEventId = object_id_1.WorkflowEventId.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.ThrowEventNodeRun.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseThrowEventNodeRun();
        message.workflowEventId = (object.workflowEventId !== undefined && object.workflowEventId !== null)
            ? object_id_1.WorkflowEventId.fromPartial(object.workflowEventId)
            : undefined;
        return message;
    },
};
function createBaseUserTaskNodeRun() {
    return { userTaskRunId: undefined };
}
exports.UserTaskNodeRun = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.userTaskRunId !== undefined) {
            object_id_1.UserTaskRunId.encode(message.userTaskRunId, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserTaskNodeRun();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.userTaskRunId = object_id_1.UserTaskRunId.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.UserTaskNodeRun.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseUserTaskNodeRun();
        message.userTaskRunId = (object.userTaskRunId !== undefined && object.userTaskRunId !== null)
            ? object_id_1.UserTaskRunId.fromPartial(object.userTaskRunId)
            : undefined;
        return message;
    },
};
function createBaseEntrypointRun() {
    return {};
}
exports.EntrypointRun = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEntrypointRun();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.EntrypointRun.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(_) {
        const message = createBaseEntrypointRun();
        return message;
    },
};
function createBaseExitRun() {
    return {};
}
exports.ExitRun = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseExitRun();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.ExitRun.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(_) {
        const message = createBaseExitRun();
        return message;
    },
};
function createBaseStartThreadRun() {
    return { childThreadId: undefined, threadSpecName: "" };
}
exports.StartThreadRun = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.childThreadId !== undefined) {
            writer.uint32(8).int32(message.childThreadId);
        }
        if (message.threadSpecName !== "") {
            writer.uint32(18).string(message.threadSpecName);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStartThreadRun();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.childThreadId = reader.int32();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.threadSpecName = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.StartThreadRun.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseStartThreadRun();
        message.childThreadId = (_a = object.childThreadId) !== null && _a !== void 0 ? _a : undefined;
        message.threadSpecName = (_b = object.threadSpecName) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseStartMultipleThreadsRun() {
    return { threadSpecName: "", childThreadIds: [] };
}
exports.StartMultipleThreadsRun = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.threadSpecName !== "") {
            writer.uint32(10).string(message.threadSpecName);
        }
        writer.uint32(18).fork();
        for (const v of message.childThreadIds) {
            writer.int32(v);
        }
        writer.ldelim();
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStartMultipleThreadsRun();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.threadSpecName = reader.string();
                    continue;
                case 2:
                    if (tag === 16) {
                        message.childThreadIds.push(reader.int32());
                        continue;
                    }
                    if (tag === 18) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.childThreadIds.push(reader.int32());
                        }
                        continue;
                    }
                    break;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.StartMultipleThreadsRun.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseStartMultipleThreadsRun();
        message.threadSpecName = (_a = object.threadSpecName) !== null && _a !== void 0 ? _a : "";
        message.childThreadIds = ((_b = object.childThreadIds) === null || _b === void 0 ? void 0 : _b.map((e) => e)) || [];
        return message;
    },
};
function createBaseWaitForThreadsRun() {
    return { threads: [] };
}
exports.WaitForThreadsRun = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.threads) {
            exports.WaitForThreadsRun_WaitForThread.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWaitForThreadsRun();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.threads.push(exports.WaitForThreadsRun_WaitForThread.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.WaitForThreadsRun.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseWaitForThreadsRun();
        message.threads = ((_a = object.threads) === null || _a === void 0 ? void 0 : _a.map((e) => exports.WaitForThreadsRun_WaitForThread.fromPartial(e))) || [];
        return message;
    },
};
function createBaseWaitForThreadsRun_WaitForThread() {
    return {
        threadEndTime: undefined,
        threadStatus: common_enums_1.LHStatus.STARTING,
        threadRunNumber: 0,
        waitingStatus: WaitForThreadsRun_WaitingThreadStatus.THREAD_IN_PROGRESS,
        failureHandlerThreadRunId: undefined,
    };
}
exports.WaitForThreadsRun_WaitForThread = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.threadEndTime !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.threadEndTime), writer.uint32(10).fork()).ldelim();
        }
        if (message.threadStatus !== common_enums_1.LHStatus.STARTING) {
            writer.uint32(16).int32((0, common_enums_1.lHStatusToNumber)(message.threadStatus));
        }
        if (message.threadRunNumber !== 0) {
            writer.uint32(24).int32(message.threadRunNumber);
        }
        if (message.waitingStatus !== WaitForThreadsRun_WaitingThreadStatus.THREAD_IN_PROGRESS) {
            writer.uint32(32).int32(waitForThreadsRun_WaitingThreadStatusToNumber(message.waitingStatus));
        }
        if (message.failureHandlerThreadRunId !== undefined) {
            writer.uint32(40).int32(message.failureHandlerThreadRunId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWaitForThreadsRun_WaitForThread();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.threadEndTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.threadStatus = (0, common_enums_1.lHStatusFromJSON)(reader.int32());
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.threadRunNumber = reader.int32();
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.waitingStatus = waitForThreadsRun_WaitingThreadStatusFromJSON(reader.int32());
                    continue;
                case 5:
                    if (tag !== 40) {
                        break;
                    }
                    message.failureHandlerThreadRunId = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.WaitForThreadsRun_WaitForThread.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseWaitForThreadsRun_WaitForThread();
        message.threadEndTime = (_a = object.threadEndTime) !== null && _a !== void 0 ? _a : undefined;
        message.threadStatus = (_b = object.threadStatus) !== null && _b !== void 0 ? _b : common_enums_1.LHStatus.STARTING;
        message.threadRunNumber = (_c = object.threadRunNumber) !== null && _c !== void 0 ? _c : 0;
        message.waitingStatus = (_d = object.waitingStatus) !== null && _d !== void 0 ? _d : WaitForThreadsRun_WaitingThreadStatus.THREAD_IN_PROGRESS;
        message.failureHandlerThreadRunId = (_e = object.failureHandlerThreadRunId) !== null && _e !== void 0 ? _e : undefined;
        return message;
    },
};
function createBaseExternalEventRun() {
    return { externalEventDefId: undefined, eventTime: undefined, externalEventId: undefined, timedOut: false };
}
exports.ExternalEventRun = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.externalEventDefId !== undefined) {
            object_id_1.ExternalEventDefId.encode(message.externalEventDefId, writer.uint32(10).fork()).ldelim();
        }
        if (message.eventTime !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.eventTime), writer.uint32(18).fork()).ldelim();
        }
        if (message.externalEventId !== undefined) {
            object_id_1.ExternalEventId.encode(message.externalEventId, writer.uint32(26).fork()).ldelim();
        }
        if (message.timedOut !== false) {
            writer.uint32(32).bool(message.timedOut);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseExternalEventRun();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.externalEventDefId = object_id_1.ExternalEventDefId.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.eventTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.externalEventId = object_id_1.ExternalEventId.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.timedOut = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.ExternalEventRun.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseExternalEventRun();
        message.externalEventDefId = (object.externalEventDefId !== undefined && object.externalEventDefId !== null)
            ? object_id_1.ExternalEventDefId.fromPartial(object.externalEventDefId)
            : undefined;
        message.eventTime = (_a = object.eventTime) !== null && _a !== void 0 ? _a : undefined;
        message.externalEventId = (object.externalEventId !== undefined && object.externalEventId !== null)
            ? object_id_1.ExternalEventId.fromPartial(object.externalEventId)
            : undefined;
        message.timedOut = (_b = object.timedOut) !== null && _b !== void 0 ? _b : false;
        return message;
    },
};
function createBaseSleepNodeRun() {
    return { maturationTime: undefined, matured: false };
}
exports.SleepNodeRun = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.maturationTime !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.maturationTime), writer.uint32(10).fork()).ldelim();
        }
        if (message.matured !== false) {
            writer.uint32(16).bool(message.matured);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSleepNodeRun();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.maturationTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.matured = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.SleepNodeRun.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseSleepNodeRun();
        message.maturationTime = (_a = object.maturationTime) !== null && _a !== void 0 ? _a : undefined;
        message.matured = (_b = object.matured) !== null && _b !== void 0 ? _b : false;
        return message;
    },
};
function createBaseFailure() {
    return {
        failureName: "",
        message: "",
        content: undefined,
        wasProperlyHandled: false,
        failureHandlerThreadrunId: undefined,
    };
}
exports.Failure = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.failureName !== "") {
            writer.uint32(10).string(message.failureName);
        }
        if (message.message !== "") {
            writer.uint32(18).string(message.message);
        }
        if (message.content !== undefined) {
            variable_1.VariableValue.encode(message.content, writer.uint32(26).fork()).ldelim();
        }
        if (message.wasProperlyHandled !== false) {
            writer.uint32(32).bool(message.wasProperlyHandled);
        }
        if (message.failureHandlerThreadrunId !== undefined) {
            writer.uint32(40).int32(message.failureHandlerThreadrunId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFailure();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.failureName = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.message = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.content = variable_1.VariableValue.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.wasProperlyHandled = reader.bool();
                    continue;
                case 5:
                    if (tag !== 40) {
                        break;
                    }
                    message.failureHandlerThreadrunId = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    create(base) {
        return exports.Failure.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseFailure();
        message.failureName = (_a = object.failureName) !== null && _a !== void 0 ? _a : "";
        message.message = (_b = object.message) !== null && _b !== void 0 ? _b : "";
        message.content = (object.content !== undefined && object.content !== null)
            ? variable_1.VariableValue.fromPartial(object.content)
            : undefined;
        message.wasProperlyHandled = (_c = object.wasProperlyHandled) !== null && _c !== void 0 ? _c : false;
        message.failureHandlerThreadrunId = (_d = object.failureHandlerThreadrunId) !== null && _d !== void 0 ? _d : undefined;
        return message;
    },
};
function toTimestamp(dateStr) {
    const date = new globalThis.Date(dateStr);
    const seconds = Math.trunc(date.getTime() / 1000);
    const nanos = (date.getTime() % 1000) * 1000000;
    return { seconds, nanos };
}
function fromTimestamp(t) {
    let millis = (t.seconds || 0) * 1000;
    millis += (t.nanos || 0) / 1000000;
    return new globalThis.Date(millis).toISOString();
}
//# sourceMappingURL=node_run.js.map